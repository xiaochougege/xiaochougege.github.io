<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>cs50系列(一)</title>
    <url>/archives/a9531e6a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="CS50-week1"><a href="#CS50-week1" class="headerlink" title="CS50-week1"></a><center>CS50-week1</h1><hr>
<h2 id="1-Hello"><a href="#1-Hello" class="headerlink" title="1. Hello"></a>1. Hello</h2><p>开篇作业，prset1.1非常简单，就是简单地在屏幕打印出每一个人编程时的第一句”Hello,World!”。当然prset1.1与众不同在于cs50基于vscode这个编辑器创建了一个codespace。在这个沙盒之中，我们需要自己安装Mingw编译器，同时该沙盒也ssh到了我们的Github上并且具有评分系统等多种功能，非常方便，一度让我感觉非常惊艳。peset1.1主要还是熟悉了一些shell指令，诸如<strong>wget,unzip,rm,cd,ls,pwd…</strong>,同时也了解到如何通过命令行来编译.c文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># include&lt;stdio.h&gt;</span><br><span class="line"># include&lt;cs50.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    string name = get_string(&quot;What is your name?&quot;);</span><br><span class="line">    printf(&quot;hello world! %s\n&quot;, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-Mario"><a href="#2-Mario" class="headerlink" title="2. Mario"></a>2. Mario</h2><p>第二个作业prset1.2主要是基于超级马里奥这个游戏关卡存在的障碍物来设计。简单来说，就是打印一个正向直角三角形和反向直角三角形，算法部分比较简单。<br><strong>对于反向三角形</strong>：</p>
<ol>
<li>首先循环n行，一个简单的for循环；</li>
<li>每行开始打印空格，经过观察发现，空格数依次减少，依旧是一个for循环，空格数为：n - 1；</li>
<li>开始打印 # ，也是一个简单的for循环，# 符号依次递增，数量与行数相等；</li>
</ol>
<p><strong>对于正向三角形</strong>：</p>
<ol>
<li>同样首先循环n行，使用简单for循环；</li>
<li>每行开始打印#，数目与行数相同。</li>
</ol>
<p><strong>mario-less</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cs50.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int height;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        height = get_int(&quot;Height:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    while (height &lt; 1 || height &gt; 8);</span><br><span class="line">    //printf(&quot;stored:%d\n&quot;, height);</span><br><span class="line">    for (int i = 0; i &lt; height; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1;j &lt; height - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k = 0;k &lt; i + 1; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;#&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    /*int i,j = 0;</span><br><span class="line">    for (i = 0;i &lt; height; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0;j &lt; i+1; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;#&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mario-more</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cs50.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int height;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        height = get_int(&quot;Height:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    while (height &lt; 1 || height &gt; 8);</span><br><span class="line">    for (int i = 0; i &lt; height; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        for (int j = 1; j &lt; height - i; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int k = 0 ; k &lt; i + 1; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;#&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;  &quot;);</span><br><span class="line">        for (int a = 0; a &lt; i + 1; a++)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;#&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="3-cash"><a href="#3-cash" class="headerlink" title="3. cash"></a>3. cash</h2><p>该作业主要考察抽象思维，同时也运用了一个贪心算法，但是我最大的收获还是了解到了各种硬币之间的大小关系。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;cs50.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int get_cents(void);</span><br><span class="line">int calculate_quarters(int cents);</span><br><span class="line">int calculate_dimes(int cents);</span><br><span class="line">int calculate_nickels(int cents);</span><br><span class="line">int calculate_pennies(int cents);</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    // Ask how many cents the customer is owed</span><br><span class="line">    int cents = get_cents();</span><br><span class="line"></span><br><span class="line">    // Calculate the number of quarters to give the customer</span><br><span class="line">    int quarters = calculate_quarters(cents);</span><br><span class="line">    cents = cents - quarters * 25;</span><br><span class="line"></span><br><span class="line">    // Calculate the number of dimes to give the customer</span><br><span class="line">    int dimes = calculate_dimes(cents);</span><br><span class="line">    cents = cents - dimes * 10;</span><br><span class="line"></span><br><span class="line">    // Calculate the number of nickels to give the customer</span><br><span class="line">    int nickels = calculate_nickels(cents);</span><br><span class="line">    cents = cents - nickels * 5;</span><br><span class="line"></span><br><span class="line">    // Calculate the number of pennies to give the customer</span><br><span class="line">    int pennies = calculate_pennies(cents);</span><br><span class="line">    cents = cents - pennies * 1;</span><br><span class="line"></span><br><span class="line">    // Sum coins</span><br><span class="line">    int coins = quarters + dimes + nickels + pennies;</span><br><span class="line"></span><br><span class="line">    // Print total number of coins to give the customer</span><br><span class="line">    printf(&quot;%i\n&quot;, coins);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int get_cents(void)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO</span><br><span class="line">    int cents;</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        cents = get_int(&quot;Change owed: &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    while (cents &lt; 0);</span><br><span class="line">    return cents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calculate_quarters(int cents)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO</span><br><span class="line">    int quarters = 0;</span><br><span class="line">    while (cents &gt;= 25)</span><br><span class="line">    &#123;</span><br><span class="line">        cents = cents - 25;</span><br><span class="line">        quarters++;</span><br><span class="line">    &#125;</span><br><span class="line">    return quarters;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calculate_dimes(int cents)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO</span><br><span class="line">    int dimes = 0;</span><br><span class="line">    while (cents &gt;= 10)</span><br><span class="line">    &#123;</span><br><span class="line">        cents = cents - 10;</span><br><span class="line">        dimes++;</span><br><span class="line">    &#125;</span><br><span class="line">    return dimes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calculate_nickels(int cents)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO</span><br><span class="line">    int nikels = 0;</span><br><span class="line">    while (cents &gt;= 5)</span><br><span class="line">    &#123;</span><br><span class="line">        cents = cents - 5;</span><br><span class="line">        nikels++;</span><br><span class="line">    &#125;</span><br><span class="line">    return nikels;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int calculate_pennies(int cents)</span><br><span class="line">&#123;</span><br><span class="line">    // TODO</span><br><span class="line">    int pennies = 0;</span><br><span class="line">    while (cents &gt;= 1)</span><br><span class="line">    &#123;</span><br><span class="line">        cents = cents - 1;</span><br><span class="line">        pennies++;</span><br><span class="line">    &#125;</span><br><span class="line">    return pennies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="4-credit"><a href="#4-credit" class="headerlink" title="4. credit"></a>4. credit</h2><p>prset1.4相对比较难，讲述了一个卢恩算法，了解到如何判断一张银行卡是否合规。算法部分主要是削减数位，保留数位，判断奇偶,相对简单。但是判断的条件比较多，非常容易缺漏。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;cs50.h&gt;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    long card;</span><br><span class="line">    //get input</span><br><span class="line">    do</span><br><span class="line">    &#123;</span><br><span class="line">        card = get_long(&quot;Number: &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    while (card &lt; 0);</span><br><span class="line">    //calculate</span><br><span class="line">    int digital = 0;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int count = 0;</span><br><span class="line">    int num2 = 0;</span><br><span class="line">    int num1 = 0;</span><br><span class="line">    int num_2 = 0;</span><br><span class="line">    while (card &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        num_2 = num;</span><br><span class="line">        num = card % 10;</span><br><span class="line">        digital ++;</span><br><span class="line">        if (digital % 2 == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            num2 = num * 2;</span><br><span class="line">            count = count + ((num2 % 10) + (num2 / 10));</span><br><span class="line">        &#125;</span><br><span class="line">        if (digital % 2 != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            num1 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        card /= 10;</span><br><span class="line">    &#125;</span><br><span class="line">    int all = num * 10 + num_2;</span><br><span class="line">    int add = count + num1;</span><br><span class="line">    if ((all &gt; 50 &amp;&amp; all &lt; 56) &amp;&amp; digital == 16 &amp;&amp; add % 10 == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;MASTERCARD\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if ((all == 34 || all == 37) &amp;&amp; add % 10 == 0 &amp;&amp; digital == 15)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;AMEX\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (num == 4 &amp;&amp; add % 10 == 0 &amp;&amp; (digital == 13 || digital == 16))</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;VISA\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;INVALID\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>cs50</tag>
      </tags>
  </entry>
  <entry>
    <title>简易Markdown笔记</title>
    <url>/archives/f823f2bf.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简易Markdown笔记"><a href="#简易Markdown笔记" class="headerlink" title="简易Markdown笔记"></a><center>简易Markdown笔记</h1><hr>
<h2 id="一-Markdown简介"><a href="#一-Markdown简介" class="headerlink" title="一. Markdown简介"></a>一. Markdown简介</h2><p>Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。同时Markdown的语法十分简单，常用的标记符号不超过十个，用于日常写作记录绰绰有余，不到半小时就能完全掌握。</p>
<h2 id="二-Markdown编辑器"><a href="#二-Markdown编辑器" class="headerlink" title="二. Markdown编辑器"></a>二. Markdown编辑器</h2><h3 id="1-vscode-插件"><a href="#1-vscode-插件" class="headerlink" title="1. vscode + 插件"></a>1. vscode + 插件</h3><p>vscode即<a href="https://code.visualstudio.com/download">Visual Studio Code</a>，默认支持 Markdown 语言。VS code作为一个流行的IDE编辑器提供了大量的快捷键来提高我们的效率，并且可以通过一些其他插件就可以有更好的 Markdown 编辑体验。<mark>总结一下就是使用 VS Code 写 Markdown 最大的好处就是：你可以使用你熟悉的 VS Code 快捷键，并且有着庞大的优秀的第三方插件。</mark><br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311030031510.png"><br>VS code具有良好的第三发插件库，如 Markdown Preview Enhanced 和 Markdown All in One等等。具体可以移步到<a href="https://orangex4.cool/post/lesson-zero-6/">orangeX大佬</a>博客查看。</p>
<h3 id="2-Typora"><a href="#2-Typora" class="headerlink" title="2. Typora"></a>2. Typora</h3><p><a href="https://typoraio.cn/">Typora</a> 是一款支持实时预览的 Markdown 文本编辑器，深受广大程序员的喜爱，简洁明了，方便操作。Typora 主打极简风格，从图片也可以看出来，Typora 显得十分「简洁」。同时，Typora 也是一款「所见即所得」的 Markdown 编辑器，如果你需要类似 Word 的体验，可以来尝试一下 Typora。<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311030042714.png"><br>遗憾的是，Typora并不是免费的，售价为「89 元」，对于学生党来说，在一众免费编辑器面前，显得并不便宜。<mark>不够目前Typora旧版可以免费使用，就是功能上有一些阉割。</mark></p>
<h2 id="三-Markdown语法"><a href="#三-Markdown语法" class="headerlink" title="三. Markdown语法"></a>三. Markdown语法</h2><h3 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h3><p>Markdown标题采用 # 来表示，其中 # 的个数表示标题级数。即创建标题，请在单词或短语前面添加 # 号。注意：<mark># 号与文字之间必须有空格</mark></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br></pre></td></tr></table></figure>
<p>显示效果：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311030050579.png"></p>
<h3 id="2-字体"><a href="#2-字体" class="headerlink" title="2. 字体"></a>2. 字体</h3><ul>
<li>加粗: 使用 <mark>** </mark>号将文字内容包裹起来即可达到加粗的效果,或者是快捷键(CTRL + B);</li>
<li>删除线: 使用<mark>~~ </mark>号将文字内容包裹起来即可实现删除线的效果;</li>
<li>斜体: 使用 <mark>* </mark>号将文字内容包裹起来即可达到加粗的效果,或者是快捷键(CTRL + I);</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**粗体**</span><br><span class="line">*斜体*</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<p>显示效果:<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031122349.png"></p>
<h3 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h3><ol>
<li>无序列表: 前面加<mark>* </mark>号后接空格，其中空格数表示列表的级数；</li>
<li>无序列表: 前面加<mark>number </mark>号后接空格。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* 无序列表</span><br><span class="line">    * 嵌套无序列表</span><br><span class="line">    * 嵌套无序列表</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">* 无序列表</span><br><span class="line">* 无序列表  </span><br><span class="line"></span><br><span class="line">1. 有序列表</span><br><span class="line">2. 有序列表</span><br></pre></td></tr></table></figure>
<p>实现效果：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031130162.png"></p>
<h3 id="4-引用与代码段"><a href="#4-引用与代码段" class="headerlink" title="4. 引用与代码段"></a>4. 引用与代码段</h3><ul>
<li>引用： 引用内容前面加<mark> &gt; </mark></li>
<li>代码段： 使用<mark>&#96;&#96;&#96;</mark>包裹代码段内容</li>
<li>分割符： —</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="quote">&gt; 引用</span></span><br><span class="line"><span class="section">&gt; 哈哈哈哈</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031139224.png"><br>实现效果：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031140067.png"></p>
<h3 id="5-表格"><a href="#5-表格" class="headerlink" title="5. 表格"></a>5. 表格</h3><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">| 表头   | 表头   |</span><br><span class="line">| ------ | ------ |</span><br><span class="line">| 哈哈   | 哈哈哈 |</span><br><span class="line">| 哈哈哈 | 哈哈   |</span><br></pre></td></tr></table></figure>
<p>实现效果：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031142128.png"><br>注意：快捷键<mark>shift + Alt + F</mark></p>
<h3 id="6-任务列表"><a href="#6-任务列表" class="headerlink" title="6. 任务列表"></a>6. 任务列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- [x] 已经完成的事 1</span><br><span class="line">- [x] 已经完成的事 2</span><br><span class="line">- [x] 已经完成的事 3</span><br><span class="line">- [ ] 仍未完成的事 4</span><br><span class="line">- [ ] 未完成【】里面是空白</span><br><span class="line">- [x] 完成【】里面是英语字母x</span><br></pre></td></tr></table></figure>
<p>实现效果：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031147434.png"></p>
<h3 id="7-图片与超链接"><a href="#7-图片与超链接" class="headerlink" title="7. 图片与超链接"></a>7. 图片与超链接</h3><ul>
<li>要添加图像，使用感叹号 (!), 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。</li>
<li>链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[blog](https://xiaochougege.github.io)</span><br><span class="line">![](本地地址/图床链接)</span><br></pre></td></tr></table></figure>
图片管理推荐使用<a href="#">PicGo + github图床</a></li>
<li>图床：通俗讲就是你把图片上传到一个图床提供者的图片服务器上，它会生成一个存储链接，你就可以随时通过这个链接就下载这个图片，而且还可以把这个链接放到 html 里或者 Markdown 文件里，浏览时再由浏览器或者阅读器自动加载出来。具体有什么用呢？对于我们的 Markdown 格式的博客而言，图片就成了一个文本，你可以把文章复制到 CSDN&#x2F;简书&#x2F;知乎&#x2F;个人博客等地方，每次换地方不需要重新上传图片，这些网站都能根据图床链接将图片加载出来。</li>
<li>PicGo 是一位中国开发者基于 electron-vue 开发的用于快速上传图片并获取图片 URL 链接的开源工具，GitHub主页：<a href="https://github.com/Molunerfinn/PicGo">PicGo</a>，作者博客：<a href="https://molunerfinn.com/">MARKSZのBlog</a>。</li>
<li>配置方法：<a href="https://zhuanlan.zhihu.com/p/489236769">点击这里</a></li>
</ul>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031207089.png"></p>
<h3 id="8-流程图"><a href="#8-流程图" class="headerlink" title="8. 流程图"></a>8. 流程图</h3><p>Markdown绘制流程图必须配合<a href="#">Markdown Preview Enhanced</a>插件来实现。<br>具体语法为以下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（刪除該文字）```mermaid</span><br><span class="line">graph TB</span><br><span class="line">    A(接口请求) --&gt; B[参数校验]</span><br><span class="line">    B[参数校验] --&gt; C&#123;校验通过?&#125;</span><br><span class="line">    C&#123;校验通过?&#125; -- 通过 --&gt; d[处理业务逻辑]</span><br><span class="line">    C&#123;校验不通过&#125; -- 不通过 --&gt; e[结束]</span><br><span class="line">    d[处理业务逻辑] --&gt; e(结束)</span><br><span class="line">（刪除該文字）```</span><br></pre></td></tr></table></figure>

<ul>
<li><p>graph声明流程图的布局方向</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>方向</th>
</tr>
</thead>
<tbody><tr>
<td>TB</td>
<td>从上到下</td>
</tr>
<tr>
<td>TD</td>
<td>从上到下</td>
</tr>
<tr>
<td>BT</td>
<td>从下到上</td>
</tr>
<tr>
<td>RL</td>
<td>从右到左</td>
</tr>
<tr>
<td>LR</td>
<td>从左到右</td>
</tr>
</tbody></table>
</li>
<li><p>流程图常用符号及含义</p>
<ol>
<li>圆角矩形：表示开始和结束<mark>()</li>
<li>矩形：表示过程，也就是整个流程中的一个环节<mark>[]</li>
<li>圆形：表示连接。为避免流程过长或有交叉，可将流程切开，圆形即相当于切 口处的连接头（成对出现）<mark>(())</li>
<li>单向箭头线段：表示流程进行方向<mark>–&gt;</li>
<li>菱形：表示判断、决策<mark>{}</li>
<li>另外还有嵌入在以上符号中的描述文本</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">graph TB</span><br><span class="line">    A(开始)</span><br><span class="line">    B[打开冰箱门]</span><br><span class="line">    C&#123;&quot;冰箱小不小？&quot;&#125;</span><br><span class="line">    D((连接))</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031224336.png"><br>显示效果：</p>
<div align=center><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031234487.png" width='30%'></div>

<p><a href="https://zhuanlan.zhihu.com/p/69495726">参考资料</a></p>
<h3 id="9-时序图"><a href="#9-时序图" class="headerlink" title="9. 时序图"></a>9. 时序图</h3><ul>
<li><p>消息语句格式为：&lt;参与者&gt; &lt;箭头&gt; &lt;参与者&gt; : &lt;描述文本&gt;。</p>
</li>
<li><p>其中 &lt;箭头&gt;的写法有：</p>
<ul>
<li>-&gt;&gt; 显示为实线箭头（主动发出消息）</li>
<li>–&gt;&gt;显示为虚线箭头（响应）</li>
<li>-x显示为末尾带「X」的实线箭头（异步消息）</li>
</ul>
</li>
<li><p>sequenceDiagram 为每幅时序图的固定开头，语句次序即为参与者横向排列次序</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(delete)```mermaid</span><br><span class="line">sequenceDiagram</span><br><span class="line">    小程序 -&gt;&gt; 小程序 : wx.login()获取code</span><br><span class="line">    小程序 -&gt;&gt; + 服务器 : wx.request()发送code</span><br><span class="line">    服务器 -&gt;&gt; + 微信服务器 : code+appid+secret</span><br><span class="line">    微信服务器 --&gt;&gt; - 服务器 : openid</span><br><span class="line">    服务器 -&gt;&gt; 服务器 : 根据openid确定用户并生成token</span><br><span class="line">    服务器 --&gt;&gt; - 小程序 : token</span><br><span class="line">(delete)```</span><br></pre></td></tr></table></figure>
<p>显示效果：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202311031251944.png"></p>
<p><a href="https://zhuanlan.zhihu.com/p/70261692">参考资料</a></p>
]]></content>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript基础语法笔记</title>
    <url>/archives/a6506496.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="JavaScript基础语法"><a href="#JavaScript基础语法" class="headerlink" title="JavaScript基础语法"></a><center>JavaScript基础语法</h1><hr>
<h2 id="一-变量案例"><a href="#一-变量案例" class="headerlink" title="一. 变量案例"></a>一. 变量案例</h2><ul>
<li>用户输入姓名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = prompt(&quot;请输入你的姓名&quot;);</span><br></pre></td></tr></table></figure>

<ul>
<li>输出用户名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alert(name);//不声明直接赋值,结果可以正常输出,但是会变成全局变量</span><br></pre></td></tr></table></figure>

<ul>
<li>交换两个变量的值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var apple1 = &#x27;红苹果&#x27;;</span><br><span class="line">var apple2 = &#x27;青苹果&#x27;;</span><br><span class="line">var temp;</span><br><span class="line">temp = apple1;</span><br><span class="line">apple1 = apple2;</span><br><span class="line">apple2 = temp;</span><br><span class="line">console.log(apple1);</span><br><span class="line">console.log(apple2);</span><br></pre></td></tr></table></figure>

<h2 id="二-数据类型"><a href="#二-数据类型" class="headerlink" title="二. 数据类型"></a>二. 数据类型</h2><p>js变量的数据类型是只有程序在运行过程中根据等号右边的值来确定的。同时js具有动态类型，相同的变量可用作不同类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var x = 10;</span><br><span class="line">x = &#x27;xiaochou&#x27;;</span><br><span class="line">console.log(x);</span><br></pre></td></tr></table></figure>
<p>js数据类型分为两大类:</p>
<ol>
<li><p>简单数据类型(Mumber, String,Boolean,Undefined,Null);</p>
<ol>
<li>数值型Number <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 八进制,数值前面加0表示八进制</span><br><span class="line">var x = 010;</span><br><span class="line">console.log(x);</span><br><span class="line">// 2.十六进制,数值前面加0x</span><br><span class="line">var x = 0x1f;</span><br><span class="line">console.log(x);</span><br><span class="line">//最值</span><br><span class="line">console.log(Number.MAX_VALUE);</span><br><span class="line">console.log(Number.MIN_VALUE);</span><br><span class="line">//无穷大</span><br><span class="line">console.log(Number.MAX_VALUE * 2);</span><br><span class="line">//无穷小</span><br><span class="line">console.log(-Number.MAX_VALUE * 2);</span><br><span class="line">//非数字NaN</span><br><span class="line">console.log(&#x27;dd&#x27; - 100);</span><br><span class="line">//isNaN判断是否为数字,会返回一个值,是数字返回false</span><br><span class="line">console.log(isNaN(12));</span><br><span class="line">console.log(isNaN(&#x27;pink&#x27;));</span><br></pre></td></tr></table></figure></li>
<li>字符串型(加单引号) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 引号嵌套(外单内双,外双内单)</span><br><span class="line">// 换行使用转义符号(\n)</span><br><span class="line">//字符串长度length</span><br><span class="line">var name = &#x27;hdhduihiwira&#x27;;</span><br><span class="line">console.log(name.length);</span><br><span class="line">//字符串的拼接(+),什么类型皆可,最终结果为字符串型</span><br><span class="line">console.log(&#x27;消愁&#x27; + &#x27;joker&#x27;);</span><br><span class="line">console.log(&#x27;xiaochou&#x27; + true);</span><br><span class="line">var age = 18;</span><br><span class="line">console.log(&#x27;今年&#x27; + age + &#x27;岁&#x27;);</span><br></pre></td></tr></table></figure></li>
<li>布尔型boolean <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> var flag = true;</span><br><span class="line">console.log(flag);</span><br></pre></td></tr></table></figure></li>
<li>Undefined未定义数据类型 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 若和数字相加,结果为NaN</span><br></pre></td></tr></table></figure></li>
<li>Null 空值 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var space = undefined;</span><br><span class="line">console.log(space);</span><br><span class="line">var spa = null;</span><br><span class="line">console.log(spa);</span><br><span class="line">//typeof获取变量数据类型</span><br><span class="line">var x = 10;</span><br><span class="line">console.log(typeof x);</span><br><span class="line">x = &#x27;xiaochou&#x27;;</span><br><span class="line">console.log(typeof x);</span><br><span class="line">//prompt获取的输入值为字符型</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>复杂数据类型(object对象，Array数组)</p>
</li>
<li><p>数据类型转换</p>
<ol>
<li>转字符串型(toString();String1()强制转换;加号拼接字符串) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var num = &#x27;10&#x27;;</span><br><span class="line">    var str = num.toString();</span><br><span class="line">    console.log(typeof str);</span><br><span class="line">    console.log(String(num));</span><br><span class="line">    console.log(&#x27;&#x27; + num); //隐式转换</span><br></pre></td></tr></table></figure></li>
<li>转数字型(parseInt(String);parseFloat(String);Number(变量)强制转换;隐式转换(-*&#x2F;)) <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(&#x27;12&#x27; - 0); //利用算数运算</span><br></pre></td></tr></table></figure></li>
<li>转化为布尔型(Booean()函数);</li>
</ol>
</li>
<li><p>简单案例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var day = prompt(&#x27;你是什么时候出生的?&#x27;); //返回字符串型</span><br><span class="line">var days = parseInt(day);</span><br><span class="line">days = 2023 - days;</span><br><span class="line">alert(&#x27;你今年&#x27; + days + &#x27;岁&#x27;);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="三-运算符"><a href="#三-运算符" class="headerlink" title="三. 运算符"></a>三. 运算符</h2><ul>
<li>(操作符)—–&gt;(+ - * &#x2F;)</li>
<li>表达式与返回值</li>
<li>自加++,自减–</li>
<li>前置:先运算后自加(先人后己)</li>
<li>后置:先自加后运算(先己后人)</li>
<li>比较运算符(关系运算符),返回布尔值</li>
<li>逻辑运算符(&amp;&amp; 与；||或；!非)</li>
<li>赋值运算符(&#x3D; +&#x3D; -&#x3D;)</li>
<li>优先级:(),一元运算符,算数运算符,关系运算符,相等运算符,逻辑运算符,赋值运算符,逗号运算符<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(133 &amp;&amp; 234); //逻辑中断:左真则返回右;左假返回左;</span><br><span class="line">console.log(123 || 345); //逻辑中断:左真返回左,左假返回右,与上面相反</span><br><span class="line">var num = 0;</span><br><span class="line">console.log(123 || num++); //123为真,输出123,num++不执行</span><br><span class="line">console.log(num); //返回0</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="四-流程控制"><a href="#四-流程控制" class="headerlink" title="四. 流程控制"></a>四. 流程控制</h2><ul>
<li>if switch 三元表达式</li>
<li>顺序结构,分支结构,循环结构</li>
<li>三元表达式 条件 ? 结果1 : 结果2  </li>
<li>if-else与switch区别:switch用于比较确定值,if-else用于判断范围。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var time = prompt(&#x27;请输入一个随机数字:&#x27;)</span><br><span class="line">var result = time &lt; 10 ? &#x27;0&#x27; + time : time;</span><br><span class="line">alert(result);</span><br><span class="line">//switch-case-break-default  执行思路:匹配</span><br><span class="line">var fruit = prompt(&#x27;请你输入水果名称:&#x27;);</span><br><span class="line">switch (fruit) &#123;</span><br><span class="line">    case &#x27;苹果&#x27;:</span><br><span class="line">        alert(&#x27;苹果价格35元&#x27;);</span><br><span class="line">        break;</span><br><span class="line">    case &#x27;香蕉&#x27;:</span><br><span class="line">        alert(&#x27;香蕉价格20元&#x27;);</span><br><span class="line">        break;</span><br><span class="line">    default:</span><br><span class="line">        alert(&#x27;没有该种水果&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>案例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">    console.log(&#x27;啊哈哈&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">//1.求1-100之间所有数都平均值</span><br><span class="line">var sum = 0;</span><br><span class="line">for (i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">&#125;</span><br><span class="line">var even = sum / 100;</span><br><span class="line">console.log(even);</span><br><span class="line">// 2.求1-100站之间所有偶数的平均值</span><br><span class="line">var sum = 0;</span><br><span class="line">var cout = 0;</span><br><span class="line">for (j = 0; j &lt;= 100; j++) &#123;</span><br><span class="line">    if (j % 2 == 0) &#123;</span><br><span class="line">        sum += j;</span><br><span class="line">        cout++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var ou = sum / cout;</span><br><span class="line">console.log(ou);</span><br></pre></td></tr></table></figure>
<h2 id="五-数组"><a href="#五-数组" class="headerlink" title="五. 数组"></a>五. 数组</h2><p>所谓数组,即一组数据的集合,存储在单个变量下。<br>在js中，创建数组有以下几种方式：</p>
<ol>
<li>new关键字创建;</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = new Array(); // 创建一个空数组</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数组字面量创建</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>数组长度 数组名.length</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [44, 23.4, 2.4, 4, 25, 2, 34];</span><br><span class="line">for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    console.log(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>求最值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [32213, 423, 4324, 35, 5, 542];</span><br><span class="line">var max = arr[0];</span><br><span class="line">for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (max &lt; arr[i]) &#123;</span><br><span class="line">        max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;该数组的最大值为&#x27; + max);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数组指定元素,例如0;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [37312, 4, 342, 4, 0, 0, 0, 32, 44, 3];</span><br><span class="line">var newArr = [];</span><br><span class="line">for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if (arr[i] != 0) &#123;</span><br><span class="line">        newArr[newArr.length] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;新数组为&#x27; + newArr);</span><br></pre></td></tr></table></figure>

<ul>
<li>冒泡排序</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr1 = [5, 4, 3, 2, 1];</span><br><span class="line">for (var i = 1; i &lt; arr1.length; i++) &#123;</span><br><span class="line">    for (var j = 0; j &lt;= arr1.length - i;++) &#123;</span><br><span class="line">        if (arr1[j] &gt; arr1[j + 1]) &#123;</span><br><span class="line">            var temp = arr1[j];</span><br><span class="line">            arr1[j] = arr1[j + 1];</span><br><span class="line">            arr1[j + 1] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;冒泡排序的结果是:&#x27; + arr1);</span><br></pre></td></tr></table></figure>

<h2 id="六-函数"><a href="#六-函数" class="headerlink" title="六. 函数"></a>六. 函数</h2><ul>
<li>函数求两个数最大值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getMax(num1, num2) &#123;</span><br><span class="line">    /* if (num1 &gt; num2) &#123;</span><br><span class="line">        return num1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return num2;</span><br><span class="line">    &#125; */</span><br><span class="line">    return num1 &gt; num2 ? num1 : num2; //元表达式;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getMax(3646, 41244));</span><br></pre></td></tr></table></figure>

<ul>
<li>函数求数组最大值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getMaxarr(arr) &#123;</span><br><span class="line">    var max = arr[0];</span><br><span class="line">    for (var i = 1; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">var result = getMaxarr([31, 31313, 12, 3243, 0]);</span><br><span class="line">console.log(result);</span><br></pre></td></tr></table></figure>

<ul>
<li>return 终止函数,碰到return后面代码不会执行</li>
<li>return 只能返回一个值(最后一个值),不过可以通过数组返回多个值</li>
<li>如果函数没返回值,则返回undefined</li>
<li>break: 结束当前循环体;</li>
<li>continue: 跳出本次循环,继续执行下次循环;</li>
<li>return: 不仅可以跳出循环,还能返回return语的值,同时可以结束函数体内的代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getSult(num1, num2) &#123;</span><br><span class="line">    return [num1, num2, num1 + num2, num1*2];</span><br><span class="line">&#125;</span><br><span class="line">console.log(getSult(1, 2));</span><br></pre></td></tr></table></figure>

<h2 id="七-作用域与预解析"><a href="#七-作用域与预解析" class="headerlink" title="七. 作用域与预解析"></a>七. 作用域与预解析</h2><ul>
<li>arguments的使用(获取传递的参数),存储传递过来的所有实参;</li>
<li>展示形式为一个伪数组,因此可以进行遍历;<ol>
<li>具有数组length属性;</li>
<li>按照索引方式存储;</li>
<li>没有真正数组的一些方法pop(),push()</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fu() &#123;</span><br><span class="line">    console.log(arguments);</span><br><span class="line">    console.log(arguments.length);</span><br><span class="line">    console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line">fu(2, 1313, 0);</span><br></pre></td></tr></table></figure>

<ul>
<li>利用函数求任意个数的最大值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getMax() &#123;</span><br><span class="line">    var max = arguments[0];</span><br><span class="line">    for (var i = 1; i &lt; arguments.length;++) &#123;</span><br><span class="line">        if (arguments[i] &gt; max) &#123;</span><br><span class="line">            max = arguments[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getMax(12, 3, 3, 24, 324, 987));</span><br></pre></td></tr></table></figure>

<ul>
<li>函数声明方式</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 1. 利用函数关键字自定义函数(命名函数)</span><br><span class="line">function fn() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 2. 函数表达式(匿名函数)</span><br><span class="line">// var 变量名 = function()&#123;&#125;</span><br><span class="line">var fun = function() &#123;</span><br><span class="line">    console.log(&#x27;我是函数表达式&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">fun(); // 变量名,非函数名,不过可以传递参数</span><br></pre></td></tr></table></figure>

<ul>
<li>作用域: 代码名字(变量)在某段范围内起作用与效果,未来提高程序可靠性,减少命名冲突</li>
<li>es6: 全局作用域,局部作用域</li>
<li>全局作用域: 整个script标签或单独js文件</li>
<li>局部作用域: 在函数内部,只在函数内部起作用(数作用域)</li>
<li>全局变量与局部变量(根据作用域的不同)</li>
<li>注意: 函数内部没有声明字节赋值使用的变量也于全局变量;函数的形参可以看作局部变量</li>
<li>全局变量只有浏览器关闭的时候才会销毁,比较内存;局部变量当程序执行完毕时销毁,节约内存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function fu() &#123;</span><br><span class="line">    num = 20;</span><br><span class="line">    console.log(num);</span><br><span class="line">&#125;</span><br><span class="line">console.log(num);</span><br></pre></td></tr></table></figure>

<ul>
<li>es5 没有块级作用域,es6才有</li>
<li>块级作用域{}</li>
<li>作用域链: 根据内部函数可以访问外部函数的机制,用链式查找决定那些数据能被内部函数访问(就近原则)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">    var num = 123;</span><br><span class="line">    function f2() &#123;</span><br><span class="line">        console.log(num);</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line">var num = 456;</span><br><span class="line">f1(); //123 </span><br></pre></td></tr></table></figure>

<ul>
<li>js运行代码时分为两步: 预解析,代码执行</li>
<li>预解析: js引擎会把js里面所有var ,function,提升到当前作用域的最前面 </li>
<li>代码执行: 按照代码书写顺序从上往下执行</li>
<li>预解析分为: 变量预解析(变量提升);函数预解析(函数提升)</li>
<li>变量提升: 将变量声明提升至当前作用域最前面,不提升赋值操作</li>
<li>函数提升: 函数声明提升,不调用函数;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1();</span><br><span class="line">console.log(c);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(a);</span><br><span class="line"></span><br><span class="line">function f1() &#123;</span><br><span class="line">    var a = b = c = 9;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">// 代码相当于</span><br><span class="line">function f1() &#123;</span><br><span class="line">    var a;</span><br><span class="line">    a = b = c = 9; // 此处bc只赋值没声明,为全局变量</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br><span class="line">f1();</span><br><span class="line">console.log(c);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(a); //报错</span><br></pre></td></tr></table></figure>

<h2 id="八-对象"><a href="#八-对象" class="headerlink" title="八. 对象"></a>八. 对象</h2><ul>
<li>对象: 无序的相关属性和方法的集合,由属性和方法组成</li>
<li>创建方法: 字面量;new Object;构造函数</li>
<li>字面量:{}里面包含了这个具体事务的属性与方法(名词与动词)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    uname: &#x27;xiaochou&#x27;,</span><br><span class="line">    age: 18,</span><br><span class="line">    sex: &#x27;男&#x27;,</span><br><span class="line">    sayHi: function() &#123;</span><br><span class="line">        console.log(&#x27;hi~&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>里面的属性与方法采用键值对的形式 键 属性名 : 值 属性值</li>
<li>中间由,隔开</li>
<li>方法冒号后跟一个匿名函数</li>
<li>调用对象属性,我们采用 对象名.属性名</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj.uname);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>对象名[‘属性名’]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(obj[&#x27;uname&#x27;]);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用对象的方法 对象名.方法名()</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj.sayHi();</span><br></pre></td></tr></table></figure>

<ul>
<li>变量与属性:都是用来存储数据,不同的是变量单独声明并赋值,单独存在;属性在对象里面,无需声明且使用时不可脱离对象</li>
<li>函数和方法: 都是实现某种功能,不同的是函数单独声明,单独存在;方法在对象里面,调用时不可脱离对象</li>
<li>new Object</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">obj.uname = &#x27;xiaochou&#x27;;</span><br><span class="line">obj.age = 18;</span><br><span class="line">obj.sex = &#x27;男&#x27;;</span><br><span class="line">obj.sayHi = function() &#123;</span><br><span class="line">        console.log(&#x27;hi~&#x27;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>利用等号赋值添加属性与方法;</li>
<li>中间用;隔开</li>
<li>调用跟前面一致</li>
<li>构造函数: 因为前面两种方式一次只能创建一个对象,里面很多属性方法相似,封装到函数里面,即将对象里面相同的属性与方法抽象出来封装到函数里面</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Star(uname, age, sex) &#123; // 构造函数名首字母大写</span><br><span class="line">    this.name = uname; // 属性与方法前面必须加this</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.sex = sex; // 无需return就可以返回结果</span><br><span class="line">&#125;</span><br><span class="line">var xc = new Star(&#x27;xiaochou&#x27;, 18, &#x27;男&#x27;); // 调用构造函数必须写new</span><br><span class="line">console.log(typeof xc); // 调用函数返回一个对象</span><br><span class="line">console.log(xc.name);</span><br></pre></td></tr></table></figure>

<ul>
<li>对象与构造函数的区别: 构造函数泛指某一大类;对象特指一个具体的事物</li>
<li>利用构造函数创建对象的过程也称为对象的实例化,通过关键字new</li>
<li>new 关键字</li>
<li>首先在内存里面创建一个空的对象,this会指向这个对象,执行构造函数里面的代码,给空对象添加属性与方法,最后返回这个对象,无需return</li>
<li>遍历对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    name: &#x27;xioacou&#x27;,</span><br><span class="line">    age: 18,</span><br><span class="line">    sex: &#x27;男&#x27;</span><br><span class="line">&#125;</span><br><span class="line">for (k in obj) &#123;</span><br><span class="line">    console.log(k); // k为变量,输出得到属性名</span><br><span class="line">    console.log(obj.k); // obj[k]得到的是属性值</span><br><span class="line">&#125;</span><br><span class="line">//使用for.. in 一般使用k 或者 key</span><br></pre></td></tr></table></figure>

<h2 id="九-内置对象"><a href="#九-内置对象" class="headerlink" title="九. 内置对象"></a>九. 内置对象</h2><ul>
<li>自定义对象,内置对象,浏览器对象</li>
<li>Math , Date , Array , String常见这四个</li>
<li>Math对象不是构造函数,无需new调用,直接使用即可</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Math.PI);</span><br><span class="line">console.log(Math.max(313, 31, 41, 24));</span><br></pre></td></tr></table></figure>

<ul>
<li>封装对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var myMath = &#123;</span><br><span class="line">    PI: 3.1415926,</span><br><span class="line">    max: function() &#123;</span><br><span class="line">        var max = arguments[0];</span><br><span class="line">        for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            if (arguments[i] &gt; max) &#123;</span><br><span class="line">                max = arguments[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;,</span><br><span class="line">    min: function() &#123;</span><br><span class="line">        var min = arguments[0];</span><br><span class="line">        for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="line">            if (arguments[i] &lt; min) &#123;</span><br><span class="line">                min = arguments[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(myMath.PI);</span><br><span class="line">console.log(myMath.max(313, 31, 41, 24));</span><br><span class="line">console.log(myMath.min(313, 31, 41, 24));</span><br></pre></td></tr></table></figure>

<ul>
<li>绝对值: Math.abs() 会把字符串型进行隐式转换成数字型</li>
<li>向下取整: Math.floor()</li>
<li>向上取整: Math.ceil()</li>
<li>四舍五入: Math.round()</li>
<li>随机数:  Math.random()返回一个随机浮点数,0-1之间[0~1),里面不跟参数</li>
<li>得到随机整数并且包含这两个数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function getRandom(min, max) &#123;</span><br><span class="line">    return Math.floor(Math.random() * (max - min + 1)) + min;</span><br><span class="line">&#125;</span><br><span class="line">console.log(getRandom(1, 100));</span><br></pre></td></tr></table></figure>

<ul>
<li>Date日期对象: 倒计时案例</li>
<li>核心算法: 输入时间减去当前时间,但是由于时分不能为负数,因此得利用时间戳通过毫秒来进行计算</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function countDown(time) &#123;</span><br><span class="line">    var nowTime = +new Date(); //+new Date()表示时间戳,即当前时间距离1970.1.1的毫秒数</span><br><span class="line">    var inputTime = +new Date(time); //表示输入时间的时间戳</span><br><span class="line">    var times = (inputTime - nowTime) / 1000; //times为计时间隔的时间,单位为秒,ms/1000=s;</span><br><span class="line">    var d = parseInt(times / 60 / 60 / 24);</span><br><span class="line">    d &lt; 10 ? &#x27;0&#x27; + d : d;</span><br><span class="line">    var h = parseInt(times / 60 / 60 % 24);</span><br><span class="line">    h &lt; 10 ? &#x27;0&#x27; + h : h;</span><br><span class="line">    var m = parseInt(times / 60 % 60);</span><br><span class="line">    m &lt; 10 ? &#x27;0&#x27; + m : m;</span><br><span class="line">    var s = parseInt(times % 60);</span><br><span class="line">    s &lt; 10 ? &#x27;0&#x27; + s : s;</span><br><span class="line">    return d + &#x27;天&#x27; + h + &#x27;时&#x27; + m + &#x27;分&#x27; + s + &#x27;秒&#x27;; //记得返回值</span><br><span class="line">&#125;</span><br><span class="line">console.log(countDown(&#x27;2023-11-2&#x27;));</span><br><span class="line">var date = new Date(); //Date对象使用需要进行实例化(泛指)</span><br><span class="line">console.log(date);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数组对象Array()</p>
</li>
<li><p>创建: </p>
<ul>
<li><p>字面量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">console.log(arr[0]);</span><br></pre></td></tr></table></figure></li>
<li><p>利用new Array()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr1 = new Array(2); //构造函数,需要进行实例化,2表示数组长度为2;</span><br><span class="line">console.log(arr1);</span><br><span class="line">var arr2 = new Array(2, 3); //等价于利用字面量创建以各[2,3]</span><br><span class="line">console.log(arr2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>翻转数组之检测是否为数组</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arrAy = [];</span><br><span class="line">console.log(arrAy.length); // 返回0,但是数组从0开始计数</span><br><span class="line">function reserve(arr3) &#123;</span><br><span class="line">    if (arr3 instanceof Array) &#123;</span><br><span class="line">        var newArr = [];</span><br><span class="line">        for (var i = arr3.length - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">            newArr[newArr.length] = arr3[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return newArr;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#x27;参数需要为数组格式!&#x27;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(reserve([1, 2, 3]));</span><br><span class="line">console.log(reserve(1, 2, 3));</span><br></pre></td></tr></table></figure>

<ul>
<li>instanceof 运算符,可以检测是否为数组</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">console.log(arr instanceof Array);</span><br><span class="line">console.log(obj instanceof Array);</span><br></pre></td></tr></table></figure>

<ul>
<li>Array.isArray(参数)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console.log(Array.isArray(arr));</span><br><span class="line">console.log(Array.isArray(obj)); //优先级更高,兼容性较差</span><br></pre></td></tr></table></figure>

<ul>
<li>添加或者删除数组元素</li>
<li><ol>
<li>push() 数组末尾添加一个或者多个,参数直接为数组元素,返回值为新数组的长度</li>
</ol>
</li>
<li><ol start="2">
<li>unshift 数组开头添加一个或者多个,参数直接为数组元素,返回值为新数组的长度</li>
</ol>
</li>
<li><ol start="3">
<li>pop() 删除数组最后一个元素,里面不跟参数,返回值为删除元素</li>
</ol>
</li>
<li><ol start="4">
<li>shift() 删除数组第一个元素,里面不跟参数,返回值为删除元素</li>
</ol>
</li>
<li>筛选数组(筛选处小于2000的元素)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr4 = [3123, 3121, 44, 343, 35, 3, 9709];</span><br><span class="line">var newArr = [];</span><br><span class="line">for (var i = 0; i &lt; arr4.length; i++) &#123;</span><br><span class="line">    if (arr4[i] &lt; 2000) &#123;</span><br><span class="line">        newArr.push(arr4[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(newArr);</span><br></pre></td></tr></table></figure>

<ul>
<li>翻转数组reverse()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr5 = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;];</span><br><span class="line">console.log(arr5.reverse());</span><br></pre></td></tr></table></figure>

<ul>
<li>冒泡排序sort()</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr6 = [12, 31421, 42, 34, 34, 323]; // 通过getString转字符串编码,不准确</span><br><span class="line">arr6.sort();</span><br><span class="line">console.log(arr6);</span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr7 = [13, 4, 77, 1, 7];</span><br><span class="line">arr7.sort(function(a, b) &#123;</span><br><span class="line">    return a - b; // 升序,若降序即b - a;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(arr7);</span><br></pre></td></tr></table></figure>

<ul>
<li>获取数组的索引号 indexOf()  只返回第一个,返回-1表示没有此元素</li>
<li>lastIndexOf()从后往前查找</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr8 = [13, 4, 77, 1, 7];</span><br><span class="line">console.log(arr8.indexOf(13));</span><br></pre></td></tr></table></figure>

<ul>
<li>数组去重案例</li>
<li>核心算法: 遍历旧数组,用旧数组元素查询新数组,若新数组没有则添加</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr9 = [&#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;c&#x27;, &#x27;b&#x27;];</span><br></pre></td></tr></table></figure>

<ul>
<li>封装一个函数来实现该功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function unique(arr) &#123;</span><br><span class="line">    var newArr = [];</span><br><span class="line">    for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        if (newArr.indexOf(arr[i]) == -1) &#123;</span><br><span class="line">            newArr[newArr.length] = arr[i];</span><br><span class="line">            // newArr.push(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return newArr;</span><br><span class="line">&#125;</span><br><span class="line">var arr9 = unique([&#x27;c&#x27;, &#x27;a&#x27;, &#x27;z&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;a&#x27;, &#x27;x&#x27;, &#x27;c&#x27;, &#x27;b&#x27;]);</span><br><span class="line">console.log(arr9);</span><br></pre></td></tr></table></figure>

<ul>
<li>数组转换为字符串<ol>
<li>toString()</li>
<li>join(分割符)</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var array = [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;pink&#x27;];</span><br><span class="line">console.log(array.join(&#x27;-&#x27;));</span><br></pre></td></tr></table></figure>

<h2 id="十-简单类型与复杂类型"><a href="#十-简单类型与复杂类型" class="headerlink" title="十. 简单类型与复杂类型"></a>十. 简单类型与复杂类型</h2><ul>
<li>对象才有属性与方法(复杂数据类型)</li>
<li>但是简单数据类型有length属性</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;aiaiaiiai&#x27;;</span><br><span class="line">console.log(str.length);</span><br></pre></td></tr></table></figure>

<ul>
<li>基本包装类型(简单数据类型包装成复杂数据类型)，相当于以下:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var temp = new String(&#x27;aiaiaiaiai&#x27;); // 通过临时变量将简单数据类型转化为复杂数据类型</span><br><span class="line">str = temp; // 将临时变量赋值给str</span><br><span class="line">temp = null; // 销毁临时变量</span><br></pre></td></tr></table></figure>

<ul>
<li>三种特殊引用类型: String,Number,Boolean</li>
<li>字符串的不可变: 里面的值是不可变的,看上去改变了内容,实际上是地址变了,在内存中开辟了一个新的空间,原来的值还是的,因此不要大量拼接字符串,比较占用内存资源</li>
<li>字符串所有的方法都不会修改字符串本身(不可变),同时操作完成后会返回一个新的字符串</li>
<li>根据字符返回位置   .indexOf(‘要查找的字符’,[起始位置])</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;改革春风吹满地,春天来了&#x27;;</span><br><span class="line">console.log(str.indexOf(&#x27;春&#x27;));</span><br><span class="line">console.log(str.indexOf(&#x27;春&#x27;, 3)); // 从索引号为3的位置往后查找</span><br></pre></td></tr></table></figure>

<ul>
<li>统计字符串O出现位置与次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str = &#x27;joergoegegoegeo&#x27;;</span><br><span class="line">var index = str.indexOf(&#x27;o&#x27;); // 先查找第一个o的位置</span><br><span class="line">var num = 0;</span><br><span class="line">while (index != -1) &#123; // 如果indexOf返回不是-1,即能够找到o,就继续向后查找</span><br><span class="line">    console.log(index);</span><br><span class="line">    num++</span><br><span class="line">    index = str.indexOf(&#x27;o&#x27;, index + 1); // 找到第一个o后从当前位置加1的索引号继续查找</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#x27;o出现的次数是:&#x27; + num)</span><br></pre></td></tr></table></figure>

<ul>
<li>根据位置返回字符<ol>
<li>charAt(index)</li>
<li>charCodeAt(index) 返回对应索引号字符的ASCII码,可用来判断用户输入了哪个键</li>
<li>str[index]  h5新增,具有兼容性问题</li>
</ol>
</li>
<li>判断是否有该属性 对象[‘属性’]</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    age: 18</span><br><span class="line">&#125;</span><br><span class="line">if (o[&#x27;age&#x27;]) &#123;</span><br><span class="line">    console.log(&#x27;存在该属性&#x27;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    console.log(&#x27;没有该属性&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>判断一个字符串中出先次数最多的字符,统计其次数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str1 = &#x27;coirohroigorgtiro&#x27;;</span><br><span class="line">var o = &#123;&#125;; // 创建一个空对象</span><br><span class="line">for (var i = 0; i &lt; str1.length; i++) &#123;</span><br><span class="line">    var chars = str1.charAt(i); // chars为遍历的每一个字符串</span><br><span class="line">    if (o[chars]) &#123; // 开始创建的空对象没有chars字符串</span><br><span class="line">        o[chars]++; // 有该属性,+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        o[chars] = 1; //给该属性赋值为1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(o);</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历对象</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var max = 0;</span><br><span class="line">var ch = &#x27;&#x27;;</span><br><span class="line">for (var k in o) &#123; // 遍历对象</span><br><span class="line">    // k得到属性名</span><br><span class="line">    // o[k]得到属性值</span><br><span class="line">    if (o[k] &gt; max) &#123;</span><br><span class="line">        max = o[k];</span><br><span class="line">        ch = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(max);</span><br><span class="line">console.log(&#x27;最多的字符是&#x27; + ch);</span><br></pre></td></tr></table></figure>

<ul>
<li>拼接字符串<ol>
<li>concat(‘字符串1’,’字符串2’,’…’) 等效+号</li>
<li>substr(‘截止起始位置’,’截取几个字符’)</li>
</ol>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str2 = &#x27;改革春风吹满地&#x27;;</span><br><span class="line">console.log(str2.substr(2, 2));</span><br></pre></td></tr></table></figure>

<ul>
<li>替换字符串 replace(‘被替换字符’,’替换为的字符’) 只会替换第一个字符</li>
<li>过滤敏感词</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var str3 = &#x27;hwifioewfowjfwpfu&#x27;;</span><br><span class="line">while (str3.indexOf(&#x27;o&#x27;) !== -1) &#123;</span><br><span class="line">    str3 = str3.replace(&#x27;o&#x27;, &#x27;*&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(str3)</span><br></pre></td></tr></table></figure>

<ul>
<li>字符转化为数组 split(‘分隔符’)</li>
<li>数组转换为字符 join(‘分隔符’)</li>
<li>简单数据类型: 值类型,即存储时变量储存但是值本身(string,number,boolean,undifined,null)</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var timer = null;</span><br><span class="line">console.log(typeof timer); // null比较特殊,返回object,即一个空的对象</span><br></pre></td></tr></table></figure>

<ul>
<li>这是一个设计时留下的bug,如果有个变量打算以后储存为对象,暂时没想好,就给null</li>
<li>栈: 操作系统自动分配释放存放函数的参数值,一般放置简单数据类型</li>
<li>堆: 存储复杂对象,一般由程序员分配释放,若不则由垃圾回收机制回收,一般存放复杂数据类型</li>
<li>内存分配: 简单数据类型存放到栈里面,开辟一个空间存放的为值,变量名指向该值;</li>
<li>复杂数据类型首先在栈里存放地址(十六进制表示),变量名指向该地址,地址指向存放在堆中的数值</li>
<li>简单数据类型传参: 传参时将变量在栈空间里面的值复制一份给形参,对形参的任何修改都不会影响外部变量</li>
<li>复杂数据类型传参:  传参时将变量在栈空间里保存的地址复制给形参,形参与实参为同一地址,所以操作的是同一对象。</li>
</ul>
]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux基础</title>
    <url>/archives/a4a81253.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a><center>Linux基础</h1><hr>
<h2 id="一-Linux起源"><a href="#一-Linux起源" class="headerlink" title="一. Linux起源"></a>一. Linux起源</h2><h3 id="1-Linux历史"><a href="#1-Linux历史" class="headerlink" title="1.Linux历史"></a>1.Linux历史</h3><ul>
<li>1969年，美国 AT&amp;T 公司贝尔实验室开发了 UNIX 操作系统</li>
<li>1983年，理查德·斯托曼在MIT发起了GNU计划，并诞生了GPL</li>
<li>1991年，林纳斯·托瓦兹在大学时期编写并发布了Linux内核</li>
<li>随后诞生了许多基于Linux内核的操作系统，称作Linux发行版</li>
<li>Linunx的发行版非常多,例如：Debian,Red Hat等分支</li>
<li><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241920079.png"></li>
<li>其中Ubuntu因为其图形界面相对比较完善,对新手入门比较友好.</li>
<li>本篇博客示例皆以Ubuntu为例</li>
</ul>
<h3 id="2-身边的Linux"><a href="#2-身边的Linux" class="headerlink" title="2.身边的Linux"></a>2.身边的Linux</h3><ul>
<li>Android其实本质上是Linux的一个发行版;</li>
<li>平常的大多数服务器也是Linux的发行版;</li>
<li>嵌入式开发板常用Linux系统.</li>
</ul>
<hr>
<h2 id="二-选择Linux的原因"><a href="#二-选择Linux的原因" class="headerlink" title="二. 选择Linux的原因"></a>二. 选择Linux的原因</h2><ul>
<li>开源:由于Linux是一个开源的操作系统,参照Linux系统,可以加深自己对于操作系统的了解;</li>
<li>安全:Linux拥有广泛,规模较大的社区维护,并且基本上四年一次更新换代,bug可以及时得到修复;</li>
<li>稳定:跟window操作系统不一样,Linux系统具有较好的稳定性,可以不间断地运行很长一段时间,不会轻易出现诸如蓝屏警告的问题,所以Linux比较适合做服务器.</li>
<li>多数没有GUI界面:通过学习Linux系统,间接掌握shell的使用方法,同时习惯命令行之后,效率可以得到大幅提高.</li>
</ul>
<hr>
<h2 id="三-window下使用Linux"><a href="#三-window下使用Linux" class="headerlink" title="三. window下使用Linux"></a>三. window下使用Linux</h2><h3 id="1-虚拟机"><a href="#1-虚拟机" class="headerlink" title="1.虚拟机"></a>1.虚拟机</h3><p>虚拟机可以视为一个安全可靠的沙盒,通过虚拟机来使用有以下优点:</p>
<ul>
<li>独立:不影响当前操作系统的使用;</li>
<li>无需考验底层应用的兼容性;</li>
<li>方便试错,不会危害本机数据.<br><strong>安装虚拟机</strong>:</li>
<li>主流软件: <a href="https://blog.csdn.net/weixin_45912291/article/details/108901106">VMware</a>,<a href="https://zhuanlan.zhihu.com/p/317188273">virtual Box</a></li>
<li><a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/">Ubuntu安装(推荐使用清华镜像)</a></li>
</ul>
<h3 id="2-WSL"><a href="#2-WSL" class="headerlink" title="2.WSL"></a>2.WSL</h3><ul>
<li><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install%E3%80%82">WSL全名:Windows Subsystem for Linux</a></li>
<li>wsl可让开发人员直接在 Windows 上按原样运行 GNU&#x2F;Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销</li>
<li>wsl1与wsl2的区别:<br> <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241923359.png"></li>
<li>以管理员身份打开powershell, 执行wsl –install, 随后重启计算机<br>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241934756.png"></li>
</ul>
<h3 id="3-双系统-不推荐"><a href="#3-双系统-不推荐" class="headerlink" title="3.双系统(不推荐)"></a>3.双系统(不推荐)</h3><ul>
<li>在安装过程中不理解关键的选项（如：磁盘分区、挂载、交换空间<br>分配等）的意义，很容易做出错误的决定；</li>
<li>错误的配置可能导致自己原先本机上的操作系统和数据遭到不可逆<br>转的损坏；</li>
<li>部分硬件可能对安装的发行版缺少兼容，从而导致意外安装失败；</li>
<li>如果安装的过程中选择下载附加工具，可能会因为默认镜像在国外<br>而导致下载十分缓慢，从而让安装流程变得很漫长；</li>
</ul>
<hr>
<h2 id="四-连接Linux服务器"><a href="#四-连接Linux服务器" class="headerlink" title="四. 连接Linux服务器"></a>四. 连接Linux服务器</h2><ul>
<li>前提:拥有服务器和账号;</li>
<li></li>
</ul>
<hr>
<h2 id="五-常见命令"><a href="#五-常见命令" class="headerlink" title="五. 常见命令"></a>五. 常见命令</h2><ul>
<li>目录结构: &#x2F;home&#x2F;username&#x2F;ding&#x2F;<br>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241935968.png"></li>
<li>显示当前的目录: pwd ———(print work directory)</li>
<li>当前目录新建文件夹: mkdir xxx.txt ——(make directory)</li>
<li>当前目录新建文件: touch xxx.c </li>
<li>进入指定目录: cd xxx,txt ————(change directory)</li>
<li>进入上一层目录: cd ..</li>
<li>查看当前目录文件: ls —————(list)</li>
<li>查看当前目录所有文件: ls -a ———(all)</li>
<li>列出文件详细信息: ls -l filename  —–(此处不会列出隐藏文件)</li>
<li>列出文件详细信息: ll —————(列出所有信息,包括隐藏的)</li>
<li>删除文件: rm a.cpp —————-(remove)</li>
<li>删除目录: rm -r filename</li>
<li>删库跑路: rm -rf &#x2F;*   ————–(注意)</li>
<li>移动文件: mv a.cpp filename&#x2F;</li>
<li>复制文件: cp a.pp filename&#x2F;</li>
<li>复制目录下所有文件: cp -r a filename</li>
<li>清屏: clear</li>
<li>显示最近执行的n条命令: history n</li>
<li>执行历史命令: !!+id</li>
<li>查看文件内容: cat a.cpp</li>
<li>输出: echo hello,world!</li>
<li>覆盖: echo ‘hello,world’ &gt; a.txt</li>
<li>追加: echo ‘welcome!’ &gt;&gt; a.txt</li>
<li>安装软件包: apt install g++</li>
<li>更新: apt update <name></li>
<li>查找: apt search <name></li>
<li>删除: apt remove <name></li>
<li>提升权限: sudo apt install g++</li>
</ul>
<hr>
<h2 id="六-vim"><a href="#六-vim" class="headerlink" title="六. vim"></a>六. vim</h2><p>vim是从vi发展而来的一个文本编辑器，对于编写程序比较方便。作为一门古老的文本编辑器,使用Vim可以大大提高编程效率.同时,<strong>它的学习成本颇为高昂</strong>.<br><em>学习vim是一个曲折的过程,但是如果仅仅只是作为了解并粗略使用的话,熟悉以下流程图就足够了.</em><br>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241937183.png"></p>
<ul>
<li>i 切换到输入模式，可以修改文件内容</li>
<li>r 切换到取代模式，可以修改文件内容</li>
<li>Esc从输入模式退出到命令模式</li>
<li>在命令模式下:<ul>
<li>输入:q 不保存退出</li>
<li>输入:w 保存</li>
<li>输入:wq 保存并退出</li>
<li>输入:wq! 强制保存并退出</li>
</ul>
</li>
</ul>
<p><em>以下vim的键盘图,感兴趣的可以尝试研究,但我认为作为一门工具,如果学习成本过高,这门工具学习的优先度不高</em></p>
<h2 id=""><a href="#" class="headerlink" title="  "></a>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241938896.png"></h2><h2 id="七-SSH"><a href="#七-SSH" class="headerlink" title="七. SSH"></a>七. SSH</h2><ul>
<li><p>SSH(Secure Shell) 是建立在应用层基础上的安全协议，可以用其远程登录服务器&#x2F;其他电脑;</p>
</li>
<li><p>SSH的登录流程(可参考计算机网络的第七章内容)<br>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241939531.png"></p>
</li>
<li><p>本地生成密钥</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">cd ~/.ssh</span><br><span class="line">cat id_rsa.pub</span><br></pre></td></tr></table></figure></li>
<li><p>将公钥添加到&#x2F;home&#x2F;user&#x2F;.ssh&#x2F;authorized_keys即可免密登录</p>
</li>
<li><p>ssh remote_username@remote_address</p>
<ul>
<li>ssh remote_username是服务器端的用户名</li>
<li>remote_address是服务器地址,可以是ip&#x2F;域名</li>
</ul>
</li>
<li><p>SCP(Secure Copy)是Linux系统下基于SSH登陆进行安全的远程文件拷贝<br>命令。</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp remote_username@remote_address:remote_filename local_folder//从服务器拷贝到本地</span><br><span class="line"></span><br><span class="line">scp local_file remote_username@remote_address:remote_folder//•从本地拷贝到服务器</span><br><span class="line"></span><br><span class="line">scp –r local_file remote_username@remote_address:remote_folder//对于文件夹需加参数-r</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="八-文件权限"><a href="#八-文件权限" class="headerlink" title="八. 文件权限"></a>八. 文件权限</h2><ul>
<li><p>Linux文件权限分为三级:文件所有者(owner)、用户组(group)、<br>其他用户(other users)</p>
</li>
<li><p>查看权限:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -l</span><br><span class="line">ll</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如图所示:<br>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241940876.png"><br>解读:</p>
<ul>
<li><p>首位表示文件类型</p>
<ul>
<li>d:文件夹</li>
<li>-:文件</li>
</ul>
</li>
<li><p>接下来每三位一组，分别代表所有者、用户组、其他用户的权限</p>
</li>
<li><p>每一组可以使用八进制数表示，也可以使用形如g&#x3D;rx表示</p>
<ul>
<li>u(user) g(group) o(others) a(all)</li>
</ul>
</li>
<li><p>chmod(change mode)是用来控制用户对文件的权限的命令</p>
</li>
<li><p>注意:只有文件所有者和超级管理员才可以修改权限</p>
</li>
<li><p>如何修改权限:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.使用字符:</span><br><span class="line">chmod a+r filename (等价于 chmod ugo+r filename)</span><br><span class="line">chmod u+w filename </span><br><span class="line">chmod ug+x,o-w filename </span><br><span class="line">chmod ug=rw,o=rx filename </span><br><span class="line">2.使用八进制数:</span><br><span class="line">chmod 777 filename (等价于 chmod a=rwx filename)</span><br><span class="line">chmod 700 filename (等价于 chmod u=rwx,go= filename)</span><br></pre></td></tr></table></figure>
<h2 id="-1"><a href="#-1" class="headerlink" title="  "></a>  <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241941192.png"></h2></li>
</ul>
<h2 id="九-tmux"><a href="#九-tmux" class="headerlink" title="九. tmux"></a>九. tmux</h2><ul>
<li>以前我们应该经常在电影中看到黑客们屏幕前滚动的帅气的终端窗口,tmux(terminal multiplexer)是一个终端复用器,它能实现在终端中同时运行多个会话,大大提高效率.<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241943979.png"><br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202303241942994.png"></li>
<li>会话(session):每次打开终端窗口(window)，输入命令。这种用户与计算机临时的交互，称作一次“会话”。每个会话都是一个独立工作区，包含一到多个窗口。</li>
<li>会话的一个特点是，窗口与其中启动的进程绑定。</li>
<li>tmux的一些基本操作:</li>
<li>安装tmux:sudo apt install tmux</li>
<li>打开tmux:tmux</li>
<li>退出tmux界面<ul>
<li>Ctrl+b后再输入d</li>
<li>Ctrl+d</li>
<li>输入exit</li>
<li>前缀键:输入Ctrl+b后，再输入的指令才会生效</li>
</ul>
</li>
<li>新建会话:tmux new -s <session_name></li>
<li>分离会话<ul>
<li>tmux detach</li>
<li>Ctrl+b d</li>
</ul>
</li>
<li>查看所有会话:tmux ls</li>
<li>接入会话: tmux attach –t <session_name></li>
<li>杀死会话:tmux kill-session -t <session_name></li>
<li>切换会话:tmux switch -t <session_name></li>
<li>重命名会话<ul>
<li>tmux rename-session -t 0 <new_name></li>
<li>Ctrl+b $ 重命名当前会话</li>
</ul>
</li>
<li>新建窗口: Ctrl+b c</li>
<li>切换窗口<ul>
<li>Ctrl+b num</li>
<li>Ctrl+b p</li>
<li>Ctrl+b n</li>
</ul>
</li>
<li>窗口划分<ul>
<li>Ctrl+b “ 上下</li>
<li>Ctrl+b % 左右</li>
<li>Ctrl+b +上下左右 切换pane</li>
</ul>
</li>
</ul>
<hr>
<h2 id="十-其他"><a href="#十-其他" class="headerlink" title="十. 其他"></a>十. 其他</h2><ul>
<li>环境变量<ul>
<li>指的是在操作系统中用来指定操作系统运行环境的一些参数，如系统文<br>件夹的位置</li>
<li>当系统执行一个程序而没有告知程序所在的完整路径时，系统除了在当前文件夹下寻找外，还会前往PATH指定路径中寻找。</li>
</ul>
</li>
<li>Linux下环境变量<ul>
<li>echo $PATH可以查看当前PATH环境变量<br>环境变量存放在~&#x2F;.bashrc中</li>
<li>source <del>&#x2F;.bashrc可以立即启用<br>每次打开shell都会执行</del>&#x2F;.bashrc</li>
</ul>
</li>
<li>内部命令 &#x2F;bin<ul>
<li>shell自带的命令，例如cd&#x2F;echo&#x2F;kill</li>
<li>效率比较高</li>
<li>内置有说明文档, help cd</li>
</ul>
</li>
<li>外部命令<ul>
<li>自己写的shell脚本，以及find等命令</li>
</ul>
</li>
<li>判断<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type cd</span><br><span class="line">type find</span><br></pre></td></tr></table></figure></li>
<li>挂起与恢复进程:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ctrl+z//可以将在前台运行的命令放到后台，并暂停</span><br><span class="line">jobs//可以查看当前在后台运行的命令</span><br><span class="line">fg %num//将后台命令调至前台</span><br><span class="line">bg %num//将后台暂停的进程在后台执行</span><br><span class="line">kill %num//终止命令编号为num的进程</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>web_lab</tag>
      </tags>
  </entry>
  <entry>
    <title>淡化成败,无问西东</title>
    <url>/archives/1c291ca3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h3><blockquote>
<p>《肖申克的救赎》中有这样一段台词：“任何一个你不喜欢又离不开的地方，任何一种你不喜欢又离不开的生活，就是监狱。如果你感到痛苦与不自由，希望你心里永远有一团不会熄灭的火焰，不要麻木，不要被同化，拼命成为一个有力量破釜沉舟的人。”</p>
</blockquote>
<p>其实这段台词告诉我们：<mark>真正的囚禁并不是外在的环境，而是我们内心的麻木与同化。<mark></p>
]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM基础(一)</title>
    <url>/archives/6abe9870.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DOM基础-一"><a href="#DOM基础-一" class="headerlink" title="DOM基础(一)"></a><center>DOM基础(一)</h1><hr>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><ol>
<li>文档对象模型,简称DOM,是一个标准编程接口;</li>
<li>DOM方便我们操作HTML;</li>
<li>DOM使HTML形成了一颗DOM操作树,包括文档,元素,节点;</li>
<li>通过DOM获取的节点返回的是一个对象(object);</li>
<li>主要由增删查改,属性操作,元素操作;</li>
</ol>
<table>
<thead>
<tr>
<th>创建</th>
<th>增</th>
<th>删</th>
<th>改</th>
</tr>
</thead>
<tbody><tr>
<td>docunment.write</td>
<td>appendChild</td>
<td>removeChild</td>
<td>修改元素属性:src,href,title等</td>
</tr>
<tr>
<td>inner.HTML</td>
<td>insertBefore</td>
<td></td>
<td>修改普通元素内容: innerHTML,innerTest</td>
</tr>
<tr>
<td>createElement</td>
<td></td>
<td></td>
<td>修改表单元素: value,type,disabled</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>修改元素样式: style,className</td>
</tr>
</tbody></table>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><table>
<thead>
<tr>
<th>DOM提供的API方法</th>
<th>H5新方法</th>
<th>节点操作元素获取</th>
</tr>
</thead>
<tbody><tr>
<td>getElementById</td>
<td>querySelector</td>
<td>父: parentNode</td>
</tr>
<tr>
<td>getElementByTagName</td>
<td>querySelectorAll</td>
<td>子: children</td>
</tr>
<tr>
<td></td>
<td></td>
<td>兄弟: previousElementSibling</td>
</tr>
<tr>
<td></td>
<td></td>
<td>兄弟: nextElementSibling</td>
</tr>
</tbody></table>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>主要针对自定义属性.</p>
<ol>
<li>setAttribute : 设置DOM属性值;</li>
<li>getAttribute : 得到DOM的属性值;</li>
<li>removeAttribute: 移除属性;</li>
</ol>
<h3 id="事件操作"><a href="#事件操作" class="headerlink" title="事件操作"></a>事件操作</h3><p>给元素注册事件,采取 <mark>事件源.事件类型 &#x3D; 事件处理程序</mark></p>
<table>
<thead>
<tr>
<th>鼠标事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onclick</td>
<td>左键点击</td>
</tr>
<tr>
<td>onmouseover</td>
<td>经过</td>
</tr>
<tr>
<td>onmouseout</td>
<td>离开</td>
</tr>
<tr>
<td>onfocus</td>
<td>获得焦点</td>
</tr>
<tr>
<td>onblur</td>
<td>失去焦点</td>
</tr>
<tr>
<td>onmousemove</td>
<td>鼠标移动</td>
</tr>
<tr>
<td>onmouseseup</td>
<td>鼠标弹起</td>
</tr>
<tr>
<td>onmousesedown</td>
<td>鼠标按下</td>
</tr>
</tbody></table>
<h3 id="动态创建元素"><a href="#动态创建元素" class="headerlink" title="动态创建元素"></a>动态创建元素</h3><ul>
<li>document.write() <ul>
<li>文档流执行完毕后页面重绘</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    document.write(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>element.innerHTML</p>
<ul>
<li>拼接字符串效率较低</li>
<li>将内容写入某个DOM节点,不会导致页面全部重绘</li>
<li>创建多个元素效率更高(非拼接字符串,采用数组形式),结构稍微复杂<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr = [];</span><br><span class="line">for (var i = 0; i &lt; 100; i++&gt;)&#123;</span><br><span class="line">    arr.push(&#x27;&lt;div&gt;&lt;/div&gt;&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">inner.HTML = arr.join(&#x27;&#x27;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>document.createElement()</p>
<ul>
<li>创建多个元素效率低一点点,结构清晰</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var create = document.querySelector(&#x27;.create&#x27;);</span><br><span class="line">for (var i = 0 ; i &lt; 100; i++)&#123;</span><br><span class="line">    var a = doocument.createElement(&#x27;a&#x27;);</span><br><span class="line">    create.append(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM基础(二)</title>
    <url>/archives/c58f0312.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="DOM基础-二"><a href="#DOM基础-二" class="headerlink" title="DOM基础(二)"></a><center>DOM基础(二)</h1><hr>
<h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><pre class="mermaid">graph TB
    A[JavaScript] ---> B((ECMAScript))--JavaScript语法--> E[JavaScript基础]
    A[JavaScript] ---> C((DOM)) --页面文档对象模型--> F[Web APIs]
    A[JavaScript] ---> D((BOM)) --浏览器对象模型--> F[Web APIs]</pre>
<h2 id="DOM简介"><a href="#DOM简介" class="headerlink" title="DOM简介"></a>DOM简介</h2><p>文档对象模型，简称DOM，是W3C组织推荐的可扩展编程语言（HTML,XML）的标准程序接口。通过这些接口可以改变网页的内容，结构与样式。</p>
<h2 id="DOM树"><a href="#DOM树" class="headerlink" title="DOM树"></a>DOM树</h2><h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2><ul>
<li>根据id获取： getElementById()</li>
<li>根据标签名获取 getElementsByTagName()</li>
<li>H5新增 getElementsByClassName(‘类名’) 根据类名获取某些元素的集合(div加.id加#)</li>
<li>H5新增 querySelector(‘选择器’) 返回指定选择器第一个元素对象</li>
<li>H5新增 querySelectorAll(‘选择器’)  返回指定选择器</li>
<li>获取body标签 document.body 返回body元素对象</li>
<li>获取html标签 document.documentElement  返回html元素对象</li>
</ul>
<h2 id="事件三要素"><a href="#事件三要素" class="headerlink" title="事件三要素"></a>事件三要素</h2><ul>
<li>事件源: 事件被触发的对象</li>
<li>事件类型: 如何触发，什么事件</li>
<li>事件处理程序： 通过一个函数赋值的形式完成</li>
</ul>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>获取事件源</li>
<li>注册事件(绑定事件)</li>
<li>添加事件处理程序(采取函数赋值形式)</li>
</ol>
<h2 id="操作元素"><a href="#操作元素" class="headerlink" title="操作元素"></a>操作元素</h2><ol>
<li><p>改变元素内容</p>
<ul>
<li>innerText  不识别HTML标签,去除空格与换行</li>
<li>innerHTML  识别HTML标签,保留空格与换行</li>
</ul>
</li>
<li><p>改变元素属性</p>
<ul>
<li><p>src &#x2F; herf</p>
<ol>
<li>获取元素</li>
<li>注册事件</li>
<li>处理程序 img.src &#x3D; ‘新路径’;</li>
</ol>
</li>
<li><p>title(鼠标经过时显示的信息)</p>
<ul>
<li>img.tilte &#x3D; ‘’;</li>
</ul>
</li>
</ul>
</li>
<li><p>改变表单属性</p>
<ul>
<li>innerHTML不可修改,只针对普通盒子(div)</li>
<li>.value 修改表单里面的值</li>
<li>.disabled &#x3D; true 禁用表单,不可点击</li>
<li>this.disabled &#x3D; true  其中this指向事件函数的调用者</li>
</ul>
</li>
<li><p>改变样式属性</p>
<ul>
<li>修改元素大小,位置,颜色</li>
<li>行内样式操作 element.style</li>
<li>类名样式操作 element.className</li>
</ul>
</li>
</ol>
<h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><ul>
<li>传统方法<ul>
<li>以on开头的方式</li>
<li>特点: 注册事件的唯一性</li>
<li>即同一元素同一事件只能设置一个处理函数,后面会将前面的覆盖</li>
</ul>
</li>
<li>方法监听注册方式<ul>
<li>addEventListener()是一个方法</li>
<li>特点: 同一元素同一事件可以设置多个监听器</li>
<li>按注册顺序依次执行</li>
<li>里面的事件类型为字符串,必加引号,不带on</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 事件监听注册事件</span><br><span class="line">var btn = document.querySelectorAll(&#x27;button&#x27;);</span><br><span class="line">btn[0].addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">    alert(&#x27;22&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">btn[1].addEventListener(&#x27;click&#x27;,function()&#123;</span><br><span class="line">    alert(&#x27;33&#x27;);</span><br><span class="line">&#125;) </span><br></pre></td></tr></table></figure>

<h3 id="删除事件-解绑事件"><a href="#删除事件-解绑事件" class="headerlink" title="删除事件(解绑事件)"></a>删除事件(解绑事件)</h3><ol>
<li>传统方式删除事件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btn[0].onclick = null;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>removeEventListener()</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btn[0].addEventListener(&#x27;click&#x27;,fn) // 无需小括号</span><br><span class="line">function fn()&#123;</span><br><span class="line">    alert(&#x27;22&#x27;);</span><br><span class="line">    btn[0].removeEventListener(&#x27;click&#x27;,fn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h3><p>事件流描述从页面接受事件的顺序,事件发生时会在元素节点之间按照特定顺序传播,这个传播过程即DOM事件流.</p>
<p>DOM事件流分为三个阶段:</p>
<ul>
<li>捕获阶段</li>
<li>当前目标阶段</li>
<li>冒泡阶段</li>
</ul>
<pre class="mermaid">graph LR
a[Docunment] --> b[Element html]
b[Element html] --> c[Element body]
c --> d[Element div]
a -.-捕获阶段-.-> d
d -.-冒泡阶段-.-> a</pre>

<ul>
<li>若addEventListener()的第三个参数为true则为<mark>捕获阶段</mark></li>
<li>若为false或者省略(默认)则为<mark>冒泡阶段</mark></li>
</ul>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><ol>
<li>event &#x2F; e为一个事件对象,写在侦听函数形参里面;</li>
<li>事件对象只有事件存在才有,系统自动创建的</li>
<li>事件对象是事件的一系列相关数据的集合</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">div.addEventListener(&#x27;click&#x27;,function(event)&#123;</span><br><span class="line">    console.log(&#x27;event&#x27;);</span><br><span class="line">&#125;);</span><br><span class="line">div.addEventListener(&#x27;click&#x27;,function(e)&#123;</span><br><span class="line">    console.log(&#x27;e&#x27;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="事件对象属性与方法"><a href="#事件对象属性与方法" class="headerlink" title="事件对象属性与方法"></a>事件对象属性与方法</h3><ol>
<li><p>target与this区别</p>
<ol>
<li>e.target 返回触发事件的对象(元素);</li>
<li>this 返回绑定事件的对象(元素);</li>
<li>currentTarget与this相近;</li>
</ol>
</li>
<li><p>e.type 返回事件行为;</p>
</li>
<li><p>阻止默认行为: </p>
<ol>
<li><a href="">e.preventDefault()</a>;</li>
<li>传统方法: <a href="">return false</a>,后面代码不再执行,只适合传统注册方式;</li>
</ol>
</li>
<li><p>阻止事件冒泡: e.stopPropagation();</p>
</li>
<li><p>事件委托(代理)</p>
<ul>
<li>不是每个子节点单独设置事件监听器,而是事件监听器设置在父节点上,利用冒泡原理影响每一个子节点;</li>
<li>作用: 只操作了一次DOM,提高程序的性能;</li>
</ul>
</li>
</ol>
<blockquote>
<p>案例: 给ul注册事件,利用事件对象target找到当前点击的li,此时世家会冒泡到ul上,ul有注册事件,依旧会触发事件监听器.</p>
</blockquote>
<h3 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h3><ol>
<li><p>禁止鼠标右键: contextmenu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docunment.addEventListener(&#x27;contextmenu&#x27;,function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁止鼠标选中: selectstart</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docunment.addEventListener(&#x27;selectstart&#x27;,function(e)&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="鼠标事件对象MouseEvent"><a href="#鼠标事件对象MouseEvent" class="headerlink" title="鼠标事件对象MouseEvent"></a>鼠标事件对象MouseEvent</h3><table>
<thead>
<tr>
<th>鼠标事件对象</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.clientX</td>
<td>返回浏览器窗口可视区x坐标</td>
</tr>
<tr>
<td>e.clientY</td>
<td>返回浏览器窗口可视区y坐标</td>
</tr>
<tr>
<td>e.screenX</td>
<td>返回鼠标相对电脑屏幕的x坐标</td>
</tr>
<tr>
<td>e.screenY</td>
<td>返回鼠标相对电脑屏幕的y坐标</td>
</tr>
<tr>
<td>e.pageX</td>
<td>返回鼠标相对页面文档的x坐标</td>
</tr>
<tr>
<td>e.pageY</td>
<td>返回鼠标相对页面文档的y坐标</td>
</tr>
</tbody></table>
<h3 id="键盘事件对象"><a href="#键盘事件对象" class="headerlink" title="键盘事件对象"></a>键盘事件对象</h3><table>
<thead>
<tr>
<th>键盘事件</th>
<th>触发条件</th>
</tr>
</thead>
<tbody><tr>
<td>onkeyup</td>
<td>某个键盘按键被松开</td>
</tr>
<tr>
<td>onketdown</td>
<td>某个键盘按键被按下</td>
</tr>
<tr>
<td>onkeypress</td>
<td>按键按下的时候</td>
</tr>
</tbody></table>
<ul>
<li>区别: keypress不能识别功能键ctrl , shift , 左右箭头等</li>
<li>执行顺序: keydown,keypress,keyup</li>
</ul>
<ol>
<li>属性: keyCode(返回相应键的ASCII值);</li>
<li>keyup和keydown不区分大小写;</li>
<li>keypress区分大小写;</li>
</ol>
<h3 id="利用节点层级获取元素"><a href="#利用节点层级获取元素" class="headerlink" title="利用节点层级获取元素"></a>利用节点层级获取元素</h3><ul>
<li>节点类型: nodeType</li>
<li>节点名称: nodeName</li>
<li>节点值: nodeValue</li>
</ul>
<h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul>
<li>元素节点: 1</li>
<li>属性节点: 2</li>
<li>文本节点: 3 (包括文字,空格,换行等)</li>
<li><mark>主要操作元素节点</mark></li>
</ul>
<h3 id="节点层级"><a href="#节点层级" class="headerlink" title="节点层级"></a>节点层级</h3><ul>
<li>父节点: parentNode (离元素最近的父节点,没有则返回null)</li>
<li>子节点: childNodes (所有子节点,存在非元素节点)</li>
<li>获取所有子元素节点: .children (常用)</li>
</ul>
<h3 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h3><ul>
<li>.firstchild  —-&gt; 第一个子节点(存在非元素节点)</li>
<li>.firstElementChild —-&gt; 返回第一个子元素节点</li>
<li>.lastElementChild  —-&gt; 返回最后一个子元素节点</li>
<li>.children[n-1] —&gt; 没有兼容性问题</li>
</ul>
<h3 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h3><ul>
<li>.nextSibling (下一个兄弟节点)</li>
<li>.previousSibling  (上一个兄弟节点)</li>
<li>.nextElementSibling —-&gt; 下一个元素兄弟节点</li>
<li>.previousElementSibling —&gt; 上一个元素节点</li>
</ul>
<h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><ul>
<li>document.createElement(‘’);  动态创建元素节点</li>
</ul>
<h3 id="添加节点"><a href="#添加节点" class="headerlink" title="添加节点"></a>添加节点</h3><ul>
<li>node.appendChild(child); <ul>
<li>将一个节点添加到指定父节点的子节点列表的末尾,类似css中的after伪元素</li>
<li>其中node为父级,child为子级</li>
<li>后面追加元素,类似数组的push()</li>
</ul>
</li>
<li>node.insertBefore(child,指定元素)   —-&gt; 在前面追加元素节点</li>
</ul>
<h3 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h3><p>先创建元素再添加元素</p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><ul>
<li>node.removeChild(child);   返回删除的子节点<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var btn = document.querySelector(&#x27;button&#x27;);</span><br><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">btn.onclick = function()&#123;</span><br><span class="line">    if (ul.children.length == 0)&#123;</span><br><span class="line">        this.disable = 0;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        ul.removeChild(ul.children[o]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><ul>
<li>node.cloneNode()   括号为空为浅拷贝,只复制节点不复制内容</li>
<li>括号为true则为深拷贝,全部复制</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var ul = document.querySelector(&#x27;ul&#x27;);</span><br><span class="line">var lili = ul.children[0].cloneNode(true);</span><br><span class="line">ul.appendChild(lili);</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
</search>
