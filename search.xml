<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/archives/1c291ca3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我的第一篇博客!!!</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊推理实验</title>
    <url>/archives/8e6ea3ca.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[top]</p>
<h1 id="人工智能原理实验"><a href="#人工智能原理实验" class="headerlink" title="人工智能原理实验"></a><center>人工智能原理实验</h1><h2 id="实验一-模糊推理实验"><a href="#实验一-模糊推理实验" class="headerlink" title="实验一 模糊推理实验"></a><center>实验一 模糊推理实验</h2><h4 id="组长"><a href="#组长" class="headerlink" title="组长:"></a>组长:</h4><h4 id="组员"><a href="#组员" class="headerlink" title="组员:"></a>组员:</h4><h4 id="指导老师"><a href="#指导老师" class="headerlink" title="指导老师:"></a>指导老师:</h4><h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>1.理解实验要求<br>2.通过操作步骤建立起模糊<br>3.通过对输入信息x和y在不同数值的情况下，观察z（洗涤时间)<br>4.理解隶属函数、模糊关系、模糊规则的关系<br>5.理解模糊推理的原理及特点,熟练应用模糊推理</p>
<h2 id="二-实验内容"><a href="#二-实验内容" class="headerlink" title="二.实验内容"></a>二.实验内容</h2><h3 id="1-洗衣机模糊推理系统实验"><a href="#1-洗衣机模糊推理系统实验" class="headerlink" title="1.洗衣机模糊推理系统实验"></a>1.洗衣机模糊推理系统实验</h3><h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>把文件washmachine.fis保存在某文件夹 。打开matlab软件，在“命令行窗口”输入命令，进入到保存上述washmachine.fis文件的文件夹。（用‘cd’命令）。<br>WashM&#x3D;readfis(‘washmachine.fis’); %模糊控制的模型已经初步建立，并保存在’washmachine.fis’文件中，通过‘readfis’命令读取并存放在WashM变量中<br>按照书本的模糊控制规则表，定义了9个对应的规则<br>rule1&#x3D;”dust&#x3D;SD &amp; gas&#x3D;NG &#x3D;&gt; washtime&#x3D;VS”;<br>rule2&#x3D;”dust&#x3D;SD &amp; gas&#x3D;MG &#x3D;&gt; washtime&#x3D;M”;<br>rule3&#x3D;”dust&#x3D;SD &amp; gas&#x3D;LG &#x3D;&gt; washtime&#x3D;L”;<br>rule4&#x3D;”dust&#x3D;MD &amp; gas&#x3D;NG &#x3D;&gt; washtime&#x3D;S”;<br>rule5&#x3D;”dust&#x3D;MD &amp; gas&#x3D;MG &#x3D;&gt; washtime&#x3D;M”;<br>rule6&#x3D;”dust&#x3D;MD &amp; gas&#x3D;LG &#x3D;&gt; washtime&#x3D;L”;<br>rule7&#x3D;”dust&#x3D;LD &amp; gas&#x3D;NG &#x3D;&gt; washtime&#x3D;M”;<br>rule8&#x3D;”dust&#x3D;LD &amp; gas&#x3D;MG &#x3D;&gt; washtime&#x3D;L”;<br>rule9&#x3D;”dust&#x3D;LD &amp; gas&#x3D;LG &#x3D;&gt; washtime&#x3D;VL”;<br>用‘addrule’命令，把以上9个规则增加到washmachine模型中</p>
<p>WashM&#x3D;addrule(WashM,rule9);<br>WashM&#x3D;addrule(WashM,rule5);<br>WashM&#x3D;addrule(WashM,rule1);<br>WashM&#x3D;addrule(WashM,rule2);<br>WashM&#x3D;addrule(WashM,rule3);<br>WashM&#x3D;addrule(WashM,rule4);<br>WashM&#x3D;addrule(WashM,rule6);<br>WashM&#x3D;addrule(WashM,rule7);<br>WashM&#x3D;addrule(WashM,rule8);<br>ruleview(WashM); </p>
<ol>
<li>用‘ruleview’命令查看上述规则的结果，会弹出GUI界面</li>
<li>在GUI界面左下方input框中以[x y]的形式输入污泥和油脂的数值，如[60 70],可以观察到右上方的washtime后面数值的变化。</li>
<li>同样，输入不同的[x y]数值，观察washtime的变化</li>
<li>也可以在GUI界面拉动dust 和 gas对应的红轴线，观察washtime数值的变化</li>
<li>点击view菜单中surface，查看推论结果立体图</li>
<li>writefis(WashM,’newwashmachine.fis’); %把最新更改后的WashM模型保存到文件’newwashmachine.fis’中</li>
<li>fuzzy(‘newwashmachine.fis’);  %用命令fuzzy查看该模型input和output的隶属函数的设定</li>
</ol>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>1.假如污泥,油脂,洗涤时间论域为(0,100),(0,100),(0,120)此时的隶属函数图如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231442483.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231442483.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231449649.png"></p>
<p>模糊控制规则表如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231449660.png"></p>
<p>推论结果立体图如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450824.png"></p>
<p>2.假定传感器测得信息污泥&#x3D;60,油脂&#x3D;70,采用模糊决策,给出推理结果.</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450024.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450920.png"></p>
<h3 id="2-树叶疾病程度认定系统"><a href="#2-树叶疾病程度认定系统" class="headerlink" title="2.树叶疾病程度认定系统"></a>2.树叶疾病程度认定系统</h3><p>利用模糊推理实现对树叶疾病程度认定的功能 </p>
<p>运行文件代码得到的GUI界面如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450997.png"><br>其中最右边两个按钮分别可以实现利用写好的模糊推理规则预测树叶生病的情况以及保存图片的功能.<br>最下面的cluster有5个选项分别选取树叶不同部位.<br>以下是举例的生病等级图:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231451685.png"></p>
<h2 id="三-实验总结"><a href="#三-实验总结" class="headerlink" title="三.实验总结"></a>三.实验总结</h2><h3 id="1-心得"><a href="#1-心得" class="headerlink" title="(1)心得"></a>(1)心得</h3><p>1.通过实验加深了对模糊逻辑的认识:经典二值逻辑中，通常以0表示“假”以1表示“真”，一个命题非真即假 。在模糊逻辑中，一个命题不再非真即假，它可以被认为是“部分的真” 。模糊逻辑取消二值之间非此即彼的对立，用隶属度表示二值间的过度状态 。模糊集合，是论域上的元素可以“部分地属于”集合A ,一个元素属于集合A的程度称为隶属度，模糊集合可用隶属度函数定义。</p>
<p>2.通过实验加深了模糊推理的理解:模糊推理可以认为是一种不精确的推理，是通过模糊规则将给定输入转化为输出的过程。模糊推理是将输入的模糊集通过一定运算对应到特定输出模糊集的计算过程。模糊规则是在进行模糊推理时依赖的规则，通常可以用自然语言表述。</p>
<p>3.同时,通过本次具体的实验,亲身感受模糊推理的魅力,让我对模糊推理的实际应用有了一定了解:模糊计算适用于：<br>（1）复杂且没有完整数学模型的非线性问题,可在不知晓具体模型的情况下利用经验规则求解。<br>（2）与其它智能算法结合实现优势互补,提供了将人类在识别、决策、理解等方面的模糊性引入机器及其控制的途径 。</p>
<p>4.通过实验过程阅读源代码以及课外资料查询,对模糊推理的设计框架整体有了一个大概的认识:模糊推理系统由五个功能模块组成：<br>    (1).包含若干模糊if-then规则的规则库；<br>    (2).定义关于使用模糊if-then规则的模糊集的隶属度函数的数据库；<br>    (3).在规则上的执行推理操作的决策单元；<br>    (4).将明确输入转化为与语言价值匹配的程度的模糊界面；<br>    (5).将推理得到的模糊结果转化为明确输出的去模糊界面。</p>
]]></content>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>算法求解八数码问题</title>
    <url>/archives/ab13bcd7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[top]</p>
<h1 id="人工智能原理实验"><a href="#人工智能原理实验" class="headerlink" title=" 人工智能原理实验"></a><center> 人工智能原理实验</h1><h2 id="实验二-算法求解八数码问题"><a href="#实验二-算法求解八数码问题" class="headerlink" title=" 实验二 算法求解八数码问题"></a><center> 实验二 算法求解八数码问题</h2><h4 id="组长"><a href="#组长" class="headerlink" title="组长:"></a>组长:</h4><h4 id="组员"><a href="#组员" class="headerlink" title="组员:"></a>组员:</h4><h4 id="指导老师"><a href="#指导老师" class="headerlink" title="指导老师:"></a>指导老师:</h4><h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><ol>
<li>熟悉与掌握启发式搜索的定义,估计函数与算法过程;</li>
<li>利用算法求解八数码难题;</li>
<li>理解求解流程与搜索顺序;</li>
<li>了解八数码的估价函数所起到的作用;</li>
<li>学习如何设计八数码的估价函数;</li>
</ol>
<h2 id="二-实验内容"><a href="#二-实验内容" class="headerlink" title="二.实验内容"></a>二.实验内容</h2><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol>
<li>把rar中所有文件解压到硬盘某文件夹</li>
<li>在matlab环境下进入该文件夹</li>
<li>执行命令 bashuma </li>
<li>代码会自动运行并观察结果尝试改变初始状态 initMatrix ，（在bashuma.m 文件中第34行附近）运行并观察命令窗口的输出的不同，观察软件运行的时间，观indexListopenList&#x2F; closeList 的长度的变化。 也可以用 % 符号把32-34行都加注注释，这样initMatrix的结果由31行的随机函数来决定；观察输出的不同。</li>
<li>把34行恢复非注释状态。</li>
<li>打开文件calH.m观察到calH( )函数调用了calH1( )函数。尝试改变代码，让calH( )函数调用calH0( )函数，运行程序 (执行命令 bashuma) ，观察软件运行时间。</li>
<li>上述calH1( )函数实际上是书本122页例5.7中所描述的第1种估价函数（针对 h(n)的估价）。尝试按照书本描述，编写第2-4种估价函数，分别命名为calH2( ) &#x2F; calH3( ) &#x2F; calH4( )  。改变代码，让calH( )函数调用上述估价函数，观察软件运行时间的变化。</li>
</ol>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><ol>
<li>当保留32行代码即initMatrix为:initMatrix() &#x3D; [ 4     1     3     0     8     5     7     6     2]时,<br>输出结果如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252333864.png"></p>
<ol start="2">
<li>当保留33行代码即initMatrix为:initMatrix() &#x3D; [ 8     1     0     5     7     2     6     3     4]时,<br>输出结果如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252334183.png"></p>
<ol start="3">
<li>当保留34行代码即initMatrix为:initMatrix() &#x3D; [ 4     1     5     3     8     7     6     0     2]时,<br>输出结果如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252334604.png"></p>
<ol start="4">
<li>当32,33,34行代码注释,使用随机函数时:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252335036.png">   </p>
<p>在这个的过程中可以非常明显地发现34行的运行速度最且indexListopenList&#x2F; closeList 的长度最短.其它两行运行速度均较长,indexListopenList&#x2F; closeList 的长度较大.</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>让calH( )函数调用calH0( )函数,此时输出结果为:<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252335710.png"></p>
<p>通过比较可知calH0()与calH1()相比,运行速度慢很多.</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p>自定义以下calH()函数:</p>
<ol>
<li>calH2():估价函数时各数码转移到目的位置所需移动的距离的总和.此时代码和输出如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252336978.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252336710.png"></p>
<ol start="2">
<li>calH3():估价函数对每一对逆转数码乘以一个倍数.此时代码和输出如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252337965.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252337941.png"></p>
<ol start="3">
<li>calH4():估价函数的位置不符合的数码总和与3倍数码逆转数目相加.代码和输出如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252337579.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252338668.png"></p>
<p>制表如下:</p>
<table>
<thead>
<tr>
<th>calh()</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>calH0()</td>
<td>494.753</td>
</tr>
<tr>
<td>calH1()</td>
<td>2.997</td>
</tr>
<tr>
<td>calH2()</td>
<td>39.616</td>
</tr>
<tr>
<td>calH3()</td>
<td>58.463</td>
</tr>
<tr>
<td>calH4()</td>
<td>2.067</td>
</tr>
</tbody></table>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h3 id="1-心得"><a href="#1-心得" class="headerlink" title="(1)心得"></a>(1)心得</h3><ol>
<li>通过本次八数码实验,加深了我对启发式搜索与估价函数的了解.由书本定义可知:启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果. </li>
<li>通过实验让我对股价函数有了深一层次的认识: 启发中的估价是用估价函数表示的，如：f(n) &#x3D; g(n) +h(n)其中f(n) 是节点n的估价函数，g(n)是在状态空间中从初始节点到n节点的实际代价，h(n)是从n到目标节点最佳路径的估计代价。 在此八数码问题中，显然g(n)就是从初始状态变换到当前状态所移动的步数，估计函数f(n)我们就可采用当前状态各个数字牌不在目标状态未知的个数，即错位数.</li>
<li>由自行设计的calH()函数在实验结果可知:当估价函数将位置不符合的数码数目总和与3倍数码逆转数目相加时,这种情况克服了数码逆转数目的策略的局限,速度相对非常快.</li>
</ol>
]]></content>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>基于深度学习的模式识别</title>
    <url>/archives/eef3c368.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>[top]</p>
<h1 id="人工智能实验"><a href="#人工智能实验" class="headerlink" title="人工智能实验"></a><center>人工智能实验</h1><h2 id="实验五-基于深度学习的模式识别实验"><a href="#实验五-基于深度学习的模式识别实验" class="headerlink" title="实验五:基于深度学习的模式识别实验"></a><center>实验五:基于深度学习的模式识别实验</h2><h4 id="组长"><a href="#组长" class="headerlink" title="组长:"></a>组长:</h4><h4 id="组员"><a href="#组员" class="headerlink" title="组员:"></a>组员:</h4><h4 id="指导老师"><a href="#指导老师" class="headerlink" title="指导老师:"></a>指导老师:</h4><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>通过构建网络模式识别实例，理解深度学习的结构和原理。</p>
<h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><ol>
<li>搭建深度学习模型，实现手写数字图像的分类,配置参数并直接运行classification命令并观察结果。</li>
<li>把rar文件所有内容复制到硬盘文件夹中，在matlab命令窗口进入到该文件夹</li>
<li>执行命令classification运行程序，系统会弹出训练样本的图样以及训练过程的误差曲线.<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271152660.png"></li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271153407.png"></p>
<h2 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h2><ol>
<li>可以在命令窗口观察到训练过程数据以及测试的结果输出（可以观察到下例中，绿色框训练准确率在不断提升，绿色框训练误差在不断减少；训练结束后最终红色框测试准确率为 91.8%）：</li>
</ol>
<p> <img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271153391.png"></p>
<ol start="2">
<li>保持其他参数不变，修改MaxEpochs的数值，观察并记录准确率的变化（MaxEpochs数值的修改在原文件的54-64行附近），并填写表格一。（表格中已填写数值为根据上图观察数据的示例）</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271155198.png">   </p>
<table>
<thead>
<tr>
<th>表格一</th>
<th>MaxEpochs</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th>;</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>最后一次训练准确率</td>
<td>60.16</td>
<td>89.84</td>
<td>79.69</td>
<td>83.59</td>
<td>85.16</td>
<td>83.59</td>
<td>82.81</td>
<td>83.59</td>
<td>88.28</td>
<td></td>
</tr>
<tr>
<td>测试准确率</td>
<td>57.14</td>
<td>91.8</td>
<td>80.357</td>
<td>83.929</td>
<td>89.286</td>
<td>91.071</td>
<td>91.071</td>
<td>92.857</td>
<td>92.857</td>
<td></td>
</tr>
</tbody></table>
<ol start="3">
<li>把MaxEpochs的数值设置为2，并把 ,…,’Plots’,’training-progress’的字样删除，如下图所示：<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271217301.png"></li>
</ol>
<p>修改卷积神经网络架构定义中convolution2dLayer的第一个参数filterSize和第二个参数numFilters。（在卷积层中，第一个参数是 filterSize，它是训练函数在沿图像扫描时使用的卷积核的高度&#x2F;宽度。在此示例中，数字 3 表示卷积核大小为 3×3。第二个参数是卷积核数量 numFilters，它是连接到同一输入区域的卷积核数量。此参数决定了特征图的数量。使用 ‘Padding’ 名称-值对组对输入特征图进行填充。对于默认步幅为 1 的卷积层，’same’ 填充可确保空间输出大小与输入大小相同。）<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271218203.png"></p>
<p>把设置两个参数不同的数值，把观察到的测试准确率的数值填到表格二中。（提示：你可以另外写一段代码，把filterSize和numFilters作为变量，写循环语句执行并记录最终结果到一个矩阵中）</p>
<table>
<thead>
<tr>
<th>numFilter卷积核<br />fliterSize</th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
</tr>
<tr>
<td>1</td>
<td>50</td>
<td>57.1429</td>
<td>60.7143</td>
<td>75</td>
<td>64.2875</td>
<td>80.3571</td>
<td>55.3571</td>
<td>69.6429</td>
<td>80.3571</td>
</tr>
<tr>
<td>2</td>
<td>64.2857</td>
<td>69.6429</td>
<td>80.3571</td>
<td>83.9286</td>
<td>78.5714</td>
<td>85.7143</td>
<td>83.9286</td>
<td>92.8571</td>
<td>92.8571</td>
</tr>
<tr>
<td>3</td>
<td>55.3571</td>
<td>71.4286</td>
<td>78.5714</td>
<td>71.4286</td>
<td>89.2857</td>
<td>89.2857</td>
<td>91.0714</td>
<td>83.9286</td>
<td>96.4286</td>
</tr>
<tr>
<td>4</td>
<td>48.2143</td>
<td>71.4286</td>
<td>85.7143</td>
<td>87.5</td>
<td>87.5</td>
<td>91.0714</td>
<td>91.0714</td>
<td>91.0714</td>
<td>91.0714</td>
</tr>
<tr>
<td>5</td>
<td>60.7143</td>
<td>75</td>
<td>78.5714</td>
<td>89.2857</td>
<td>85.7143</td>
<td>92.8571</td>
<td>87.5</td>
<td>85.7143</td>
<td>92.8571</td>
</tr>
</tbody></table>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271408295.png"><br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211271409448.png"></p>
<p>上图的网络框架中，增加了红色部分（图中，红色部分与绿色部分一样），使得网络框架加深。也可以继续增加网络深度，如上右图所示。同样，每一行的convolution2dLayer的参数都可以修改成不同的数值。</p>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h3 id="1-心得"><a href="#1-心得" class="headerlink" title="(1)心得"></a>(1)心得</h3><ol>
<li>通过本次实验,初步理解深度学习的结构和原理,体会到了卷积核对于深度学习的作用.</li>
<li>在本次实验可以发现:较大的卷积核，受限于计算能力和模型结构的设计，无法将网络叠加得很深，因此卷积网络中的卷积层需要设置较大的卷积核以获取更大的感受域。但是这种大卷积核反而会导致计算量大幅增加，不利于训练更深层的模型，相应的计算性能也会降低.通过堆叠较少的卷积核可以获得与卷积核相同的感受视野，同时参数量会更少，卷因此可以认为，在大多数情况下通过堆叠较小的卷积核比直接采用单个更大的卷积核会更加有效。</li>
<li>通过课外收集资料可以发现:在某些领域应用卷积神经网络时仍然可以采用较大的卷积核。譬如在自然语言处理领域，由于文本内容不像图像数据可以对特征进行很深层的抽象，往往在该领域的特征提取只需要较浅层的神经网络即可。在将卷积神经网络应用在自然语言处理领域时，通常都是较为浅层的卷积层组成，但是文本特征有时又需要有较广的感受域让模型能够组合更多的特征（如词组和字符），此时直接采用较大的卷积核将是更好的选择。综上所述，卷积核的大小并没有绝对的优劣，需要视具体的应用场景而定，但是极大和极小的卷积核都是不合适的，单独的极小卷积核只能用作分离卷积而不能对输入的原始特征进行有效的组合，极大的卷积核通常会组合过多的无意义特征从而浪费了大量的计算资源。</li>
<li>该次实验主要时运用了卷积神经网络的知识:卷积神经网络是一种深度学习模型或类似于人工神经网络的多层感知器，常用来分析视觉图像。卷积神经网络依旧是层级网络，只是层的功能和形式做了变化，可以说是传统神经网络的一个改进,在卷积神经网络中，卷积常用来提取图像的特征.</li>
<li>其中卷积神经网络的池化层也非常重要:池化层夹在连续的卷积层中间， 用于压缩数据和参数的量，减小过拟合。简而言之，如果输入是图像的话，那么池化层的最主要作用就是压缩图像。</li>
</ol>
<h3 id="2-改进"><a href="#2-改进" class="headerlink" title="(2)改进"></a>(2)改进</h3>]]></content>
      <tags>
        <tag>学习报告</tag>
      </tags>
  </entry>
</search>
