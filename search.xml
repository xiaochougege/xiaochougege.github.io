<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World!</title>
    <url>/archives/1c291ca3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>我的第一篇博客!!!</p>
]]></content>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊推理实验</title>
    <url>/archives/8e6ea3ca.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="人工智能原理实验"><a href="#人工智能原理实验" class="headerlink" title="人工智能原理实验"></a><center>人工智能原理实验</h1><h2 id="实验一-模糊推理实验"><a href="#实验一-模糊推理实验" class="headerlink" title="实验一 模糊推理实验"></a><center>实验一 模糊推理实验</h2><h4 id="组长"><a href="#组长" class="headerlink" title="组长:"></a>组长:</h4><h4 id="组员"><a href="#组员" class="headerlink" title="组员:"></a>组员:</h4><h4 id="指导老师"><a href="#指导老师" class="headerlink" title="指导老师:"></a>指导老师:</h4><h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><p>1.理解实验要求<br>2.通过操作步骤建立起模糊<br>3.通过对输入信息x和y在不同数值的情况下，观察z（洗涤时间)<br>4.理解隶属函数、模糊关系、模糊规则的关系<br>5.理解模糊推理的原理及特点,熟练应用模糊推理</p>
<h2 id="二-实验内容"><a href="#二-实验内容" class="headerlink" title="二.实验内容"></a>二.实验内容</h2><h3 id="1-洗衣机模糊推理系统实验"><a href="#1-洗衣机模糊推理系统实验" class="headerlink" title="1.洗衣机模糊推理系统实验"></a>1.洗衣机模糊推理系统实验</h3><h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>把文件washmachine.fis保存在某文件夹 。打开matlab软件，在“命令行窗口”输入命令，进入到保存上述washmachine.fis文件的文件夹。（用‘cd’命令）。<br>WashM&#x3D;readfis(‘washmachine.fis’); %模糊控制的模型已经初步建立，并保存在’washmachine.fis’文件中，通过‘readfis’命令读取并存放在WashM变量中<br>按照书本的模糊控制规则表，定义了9个对应的规则<br>rule1&#x3D;”dust&#x3D;SD &amp; gas&#x3D;NG &#x3D;&gt; washtime&#x3D;VS”;<br>rule2&#x3D;”dust&#x3D;SD &amp; gas&#x3D;MG &#x3D;&gt; washtime&#x3D;M”;<br>rule3&#x3D;”dust&#x3D;SD &amp; gas&#x3D;LG &#x3D;&gt; washtime&#x3D;L”;<br>rule4&#x3D;”dust&#x3D;MD &amp; gas&#x3D;NG &#x3D;&gt; washtime&#x3D;S”;<br>rule5&#x3D;”dust&#x3D;MD &amp; gas&#x3D;MG &#x3D;&gt; washtime&#x3D;M”;<br>rule6&#x3D;”dust&#x3D;MD &amp; gas&#x3D;LG &#x3D;&gt; washtime&#x3D;L”;<br>rule7&#x3D;”dust&#x3D;LD &amp; gas&#x3D;NG &#x3D;&gt; washtime&#x3D;M”;<br>rule8&#x3D;”dust&#x3D;LD &amp; gas&#x3D;MG &#x3D;&gt; washtime&#x3D;L”;<br>rule9&#x3D;”dust&#x3D;LD &amp; gas&#x3D;LG &#x3D;&gt; washtime&#x3D;VL”;<br>用‘addrule’命令，把以上9个规则增加到washmachine模型中</p>
<p>WashM&#x3D;addrule(WashM,rule9);<br>WashM&#x3D;addrule(WashM,rule5);<br>WashM&#x3D;addrule(WashM,rule1);<br>WashM&#x3D;addrule(WashM,rule2);<br>WashM&#x3D;addrule(WashM,rule3);<br>WashM&#x3D;addrule(WashM,rule4);<br>WashM&#x3D;addrule(WashM,rule6);<br>WashM&#x3D;addrule(WashM,rule7);<br>WashM&#x3D;addrule(WashM,rule8);<br>ruleview(WashM); </p>
<ol>
<li>用‘ruleview’命令查看上述规则的结果，会弹出GUI界面</li>
<li>在GUI界面左下方input框中以[x y]的形式输入污泥和油脂的数值，如[60 70],可以观察到右上方的washtime后面数值的变化。</li>
<li>同样，输入不同的[x y]数值，观察washtime的变化</li>
<li>也可以在GUI界面拉动dust 和 gas对应的红轴线，观察washtime数值的变化</li>
<li>点击view菜单中surface，查看推论结果立体图</li>
<li>writefis(WashM,’newwashmachine.fis’); %把最新更改后的WashM模型保存到文件’newwashmachine.fis’中</li>
<li>fuzzy(‘newwashmachine.fis’);  %用命令fuzzy查看该模型input和output的隶属函数的设定</li>
</ol>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>1.假如污泥,油脂,洗涤时间论域为(0,100),(0,100),(0,120)此时的隶属函数图如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231442483.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231442483.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231449649.png"></p>
<p>模糊控制规则表如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231449660.png"></p>
<p>推论结果立体图如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450824.png"></p>
<p>2.假定传感器测得信息污泥&#x3D;60,油脂&#x3D;70,采用模糊决策,给出推理结果.</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450024.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450920.png"></p>
<h3 id="2-树叶疾病程度认定系统"><a href="#2-树叶疾病程度认定系统" class="headerlink" title="2.树叶疾病程度认定系统"></a>2.树叶疾病程度认定系统</h3><p>利用模糊推理实现对树叶疾病程度认定的功能 </p>
<p>运行文件代码得到的GUI界面如下:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231450997.png"><br>其中最右边两个按钮分别可以实现利用写好的模糊推理规则预测树叶生病的情况以及保存图片的功能.<br>最下面的cluster有5个选项分别选取树叶不同部位.<br>以下是举例的生病等级图:</p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211231451685.png"></p>
<h2 id="三-实验总结"><a href="#三-实验总结" class="headerlink" title="三.实验总结"></a>三.实验总结</h2><h3 id="1-心得"><a href="#1-心得" class="headerlink" title="(1)心得"></a>(1)心得</h3><p>1.通过实验加深了对模糊逻辑的认识:经典二值逻辑中，通常以0表示“假”以1表示“真”，一个命题非真即假 。在模糊逻辑中，一个命题不再非真即假，它可以被认为是“部分的真” 。模糊逻辑取消二值之间非此即彼的对立，用隶属度表示二值间的过度状态 。模糊集合，是论域上的元素可以“部分地属于”集合A ,一个元素属于集合A的程度称为隶属度，模糊集合可用隶属度函数定义。</p>
<p>2.通过实验加深了模糊推理的理解:模糊推理可以认为是一种不精确的推理，是通过模糊规则将给定输入转化为输出的过程。模糊推理是将输入的模糊集通过一定运算对应到特定输出模糊集的计算过程。模糊规则是在进行模糊推理时依赖的规则，通常可以用自然语言表述。</p>
<p>3.同时,通过本次具体的实验,亲身感受模糊推理的魅力,让我对模糊推理的实际应用有了一定了解:模糊计算适用于：<br>（1）复杂且没有完整数学模型的非线性问题,可在不知晓具体模型的情况下利用经验规则求解。<br>（2）与其它智能算法结合实现优势互补,提供了将人类在识别、决策、理解等方面的模糊性引入机器及其控制的途径 。</p>
<p>4.通过实验过程阅读源代码以及课外资料查询,对模糊推理的设计框架整体有了一个大概的认识:模糊推理系统由五个功能模块组成：<br>    (1).包含若干模糊if-then规则的规则库；<br>    (2).定义关于使用模糊if-then规则的模糊集的隶属度函数的数据库；<br>    (3).在规则上的执行推理操作的决策单元；<br>    (4).将明确输入转化为与语言价值匹配的程度的模糊界面；<br>    (5).将推理得到的模糊结果转化为明确输出的去模糊界面。</p>
]]></content>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
  <entry>
    <title>算法求解八数码问题</title>
    <url>/archives/ab13bcd7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="人工智能原理实验"><a href="#人工智能原理实验" class="headerlink" title=" 人工智能原理实验"></a><center> 人工智能原理实验</h1><h2 id="实验二-算法求解八数码问题"><a href="#实验二-算法求解八数码问题" class="headerlink" title=" 实验二 算法求解八数码问题"></a><center> 实验二 算法求解八数码问题</h2><h4 id="组长"><a href="#组长" class="headerlink" title="组长:"></a>组长:</h4><h4 id="组员"><a href="#组员" class="headerlink" title="组员:"></a>组员:</h4><h4 id="指导老师"><a href="#指导老师" class="headerlink" title="指导老师:"></a>指导老师:</h4><h2 id="一-实验目的"><a href="#一-实验目的" class="headerlink" title="一.实验目的"></a>一.实验目的</h2><ol>
<li>熟悉与掌握启发式搜索的定义,估计函数与算法过程;</li>
<li>利用算法求解八数码难题;</li>
<li>理解求解流程与搜索顺序;</li>
<li>了解八数码的估价函数所起到的作用;</li>
<li>学习如何设计八数码的估价函数;</li>
</ol>
<h2 id="二-实验内容"><a href="#二-实验内容" class="headerlink" title="二.实验内容"></a>二.实验内容</h2><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol>
<li>把rar中所有文件解压到硬盘某文件夹</li>
<li>在matlab环境下进入该文件夹</li>
<li>执行命令 bashuma </li>
<li>代码会自动运行并观察结果尝试改变初始状态 initMatrix ，（在bashuma.m 文件中第34行附近）运行并观察命令窗口的输出的不同，观察软件运行的时间，观indexListopenList&#x2F; closeList 的长度的变化。 也可以用 % 符号把32-34行都加注注释，这样initMatrix的结果由31行的随机函数来决定；观察输出的不同。</li>
<li>把34行恢复非注释状态。</li>
<li>打开文件calH.m观察到calH( )函数调用了calH1( )函数。尝试改变代码，让calH( )函数调用calH0( )函数，运行程序 (执行命令 bashuma) ，观察软件运行时间。</li>
<li>上述calH1( )函数实际上是书本122页例5.7中所描述的第1种估价函数（针对 h(n)的估价）。尝试按照书本描述，编写第2-4种估价函数，分别命名为calH2( ) &#x2F; calH3( ) &#x2F; calH4( )  。改变代码，让calH( )函数调用上述估价函数，观察软件运行时间的变化。</li>
</ol>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><ol>
<li>当保留32行代码即initMatrix为:initMatrix() &#x3D; [ 4     1     3     0     8     5     7     6     2]时,<br>输出结果如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252333864.png"></p>
<ol start="2">
<li>当保留33行代码即initMatrix为:initMatrix() &#x3D; [ 8     1     0     5     7     2     6     3     4]时,<br>输出结果如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252334183.png"></p>
<ol start="3">
<li>当保留34行代码即initMatrix为:initMatrix() &#x3D; [ 4     1     5     3     8     7     6     0     2]时,<br>输出结果如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252334604.png"></p>
<ol start="4">
<li>当32,33,34行代码注释,使用随机函数时:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252335036.png">   </p>
<p>在这个的过程中可以非常明显地发现34行的运行速度最且indexListopenList&#x2F; closeList 的长度最短.其它两行运行速度均较长,indexListopenList&#x2F; closeList 的长度较大.</p>
<h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>让calH( )函数调用calH0( )函数,此时输出结果为:<br><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252335710.png"></p>
<p>通过比较可知calH0()与calH1()相比,运行速度慢很多.</p>
<h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><p>自定义以下calH()函数:</p>
<ol>
<li>calH2():估价函数时各数码转移到目的位置所需移动的距离的总和.此时代码和输出如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252336978.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252336710.png"></p>
<ol start="2">
<li>calH3():估价函数对每一对逆转数码乘以一个倍数.此时代码和输出如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252337965.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252337941.png"></p>
<ol start="3">
<li>calH4():估价函数的位置不符合的数码总和与3倍数码逆转数目相加.代码和输出如下:</li>
</ol>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252337579.png"></p>
<p><img src="https://gcore.jsdelivr.net/gh/xiaochougege/picture.bed/img/202211252338668.png"></p>
<p>制表如下:</p>
<table>
<thead>
<tr>
<th>calh()</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td>calH0()</td>
<td>494.753</td>
</tr>
<tr>
<td>calH1()</td>
<td>2.997</td>
</tr>
<tr>
<td>calH2()</td>
<td>39.616</td>
</tr>
<tr>
<td>calH3()</td>
<td>58.463</td>
</tr>
<tr>
<td>calH4()</td>
<td>2.067</td>
</tr>
</tbody></table>
<h2 id="实验总结"><a href="#实验总结" class="headerlink" title="实验总结"></a>实验总结</h2><h3 id="1-心得"><a href="#1-心得" class="headerlink" title="(1)心得"></a>(1)心得</h3><ol>
<li>通过本次八数码实验,加深了我对启发式搜索与估价函数的了解.由书本定义可知:启发式搜索就是在状态空间中的搜索对每一个搜索的位置进行评估，得到最好的位置，再从这个位置进行搜索直到目标。这样可以省略大量无畏的搜索路径，提到了效率。在启发式搜索中，对位置的估价是十分重要的。采用了不同的估价可以有不同的效果. </li>
<li>通过实验让我对股价函数有了深一层次的认识: 启发中的估价是用估价函数表示的，如：f(n) &#x3D; g(n) +h(n)其中f(n) 是节点n的估价函数，g(n)是在状态空间中从初始节点到n节点的实际代价，h(n)是从n到目标节点最佳路径的估计代价。 在此八数码问题中，显然g(n)就是从初始状态变换到当前状态所移动的步数，估计函数f(n)我们就可采用当前状态各个数字牌不在目标状态未知的个数，即错位数.</li>
<li>由自行设计的calH()函数在实验结果可知:当估价函数将位置不符合的数码数目总和与3倍数码逆转数目相加时,这种情况克服了数码逆转数目的策略的局限,速度相对非常快.</li>
</ol>
]]></content>
      <tags>
        <tag>实验报告</tag>
      </tags>
  </entry>
</search>
